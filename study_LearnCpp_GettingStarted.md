# Getting Started
- Following the guide https://www.learncpp.com

## Introduction to C/C++
### Before C++, there was C
- The C language was developed in 1972 by Dennis Ritchie at Bell Telephone laboratories, primarily as a systems programming language (a language to write operating systems with).
- C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrote most of the Unix operating systems using C (as opposed to Assembly).
	- Unlike Assembly, which produces programs that can only run on specific CPUs, C has excellent portability, allowing Unix to be easily recompiled on many different types of computers.
	- C and Unix had their fortunes tied together.
- In 1978, Brian Kernighan and Dennis Ritchie published a book called "The C Programming Language".
	- This book was commonly known as K&R.
	- This book provided an informal specification for the language and became a de facto standard.
- In 1983, the American National Standards Institute (ANSI) formed a committee to establish a formal standard for C.
	- In 1989, the C89 standard was released. It's more commonly known as ANSI C.
	- In 1990, the International Organization for Standardization (ISO) adopted ANSI C. This became known as C90.
- In 1999, the ISO committee released a new version of C called C99.
	- C99 adopted many features which had already made their way into compilers as extensions, or had been implemented in C++.

### C++
- In 1979, C++ was developed by Bjarne Stroustrup at Bell Labs as an extension to C.
- C++ adds many new feature to the C language, and is perhaps best thought of as a superset of C (though not strictly true).
- C++ is an object-oriented language. More on this will be covered later.
- C++ was standardized in 1998 by the ISO committee.
	- A minor update to the language was released in 2003, called C++03.
- Five major updates to the C++ language (C++11, 14, 17, 20, and 23) have been made since then, each adding additional functionality.
	- C++11 in particular added a huge number of new capabilities, and is widely considered to be the new baseline version of the language.
- Each new formal release of the language is called a **Language Standard** or **Language Specification**.
	- Standards are named after the year they are released in.

### C/C++'s Philosophy
- The underlying design philosophy of C and C++ can be summed up as "Trust the Programmer".
- C++ is designed to allow the programmer a high degree of freedom to do what they want.
	- However, this also means the language often won't stop the programmer from doing things that doesn't make sense.
	- Knowing what shouldn't be done in C/C++ is just as important as knowing what should be done.

>[!important] What is C++ good at?
>C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of application that most likely would be written in C++:
>- Video games
>- Real-time systems (e.g. transportation, manufacturing, etc.)
>- High-performance financial applications
>- Graphical applications and simulations
>- Productivity / office applications
>- Embedded software
>- Audio and video processing
>- AI/ML

## Introduction to C++ development
- There are 7 steps to C++ development:
	1. Define the problem to solve
	2. Design a solution
	3. Write a program that implements the solution
	4. Compile the program
	5. Link object files
	6. Test program
	7. Debug

### Step 4: Compiling your source code
- A C++ compiler is used to compile C++ source code files.
- The C++ compiler sequentially goes through each source code (`.cpp`) file in your program, and does two important tasks:
	- The compiler checks your C++ code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error. The compilation process will also be aborted until the error is fixed.
	- The compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. The object file also contains metadata that is required or useful in subsequent steps.
- Object files are typically named `name.o` or `name.obj`, where the `name` is the same name as the `name.cpp` file it was produced from.
- Installing a compiler will be covered later.

### Step 5: Linking object files and libraries
- After the compiler has successfully finished, another program called the **linker** kicks in.
	- The linker's job is to combine all of the object files and produce the desired output file (typically an executable file). This process is called **linking**.
- The linker has three main functionalities:
	- The linker reads in each of the object files generated by the compiler and makes sure they are valid.
	- The linker ensures all cross-file dependencies are resolved properly. For example, if you define something in one `.cpp` file, and then use it in a different `.cpp` file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you'll get a linker error, and the linking process will abort.
	- The linker also is capable of linking library files. A **library file** is a collection of precompiled code that has been "packaged up" for reuse in other programs.
- C++ comes with an extensive library called the **C++ Standard Library** that provides a set of useful capabilities for use in your programs.
	- Almost every C++ program written utilizes the standard library in some form, so it's very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn't something you need to worry about.
- You can also optionally link other libraries.
- Once the linker has finished linking all the object files and libraries successfully, then you will have an executable file that you can run.

>[!important] Building
>Because there are multiple steps involved, the term **building** is often used to refer to the full process of converting source code files into an executable that can be run. A specific executable produced as the result of building is sometimes called a **build**.
>For complex projects, build automation tools (such as make or build2) are often used to help automate the process of building programs and running automated tests.

### Steps 6 & 7: Testing and Debugging
- You run the executable and see whether it produces the output you were expecting. If not, it's time for some debugging to figure out what's wrong.
- We'll cover more on this topic later on.

>[!important] Integrated Development Environment (IDE)
>Note that steps 3, 4, 5, and 7 all involve software programs that must be installed; such as editor, compiler, linker, and debugger. While you can use separate programs for each of these activities, a software package known as an Integrated Development Environment (IDE) bundles and integrates all of these features together.


## Installing an IDE
- An Integrated Development Environment (IDE) is a piece of software designed to make it easy to develop, build, and debug your programs.
- A typical modern IDE will include:
	- Some way to easily load and save your code files.
	- A code editor that has programming-friendly features, such as line numbering, syntax highlighting and such.
	- A basic build system that will allow you to compile and link your program into an executable, and then run it.
	- An integrated debugger.
	- Some way to install plugins.
- Some C++ IDEs will install and configure a C++ compiler and linker for you. Others will allow you to plug in a compiler and linker of your choice (installed separately).

### Choosing an IDE
- It's recommended to select an IDE that comes with a compiler that supports at least C++17.
- You should NOT be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).
- These are the absolute minimum compiler versions with C++17 support:
	- GCC/G++ 7
	- Clang++ 8
	- Visual Studio 2017 15.7
- This guide recommends using Visual Studio 2022.
- Do not use Visual Studio Code unless you are an experienced user.

## Compiling your first program
- To write a C++ program inside an IDE, we typically start by creating a new project.
- A **project** is a container that holds all of your source code files, images, data files, and etc., that are needed to produce an executable that you can run or use.
- The project also saves various IDE, compiler, and linker settings, as well as remembering where you left off.
- When you choose to compile your program, all of the `.cpp` files in the project will get compiled and linked.
- Each project corresponds to one program.
- Project files are generally IDE specific, so a project created for one IDE will need to be recreated in a different IDE.
	- CMAKE is a tool that's typically used to convert a project from another environment to a project that's suited for the current environment.

### Workspaces / solutions
- When you create a new project for your program, many IDEs will automatically add your project to a "workspace" or a "solution" (the term varies by IDE).
- A **workspace/solution** is a container that can hold one or more related projects.
	- For example, if you were writing a game and wanted to have a separate executable for single player and multiplayer, you'd need to create two projects. It wouldn't make sense for both of these projects to be completely independent - after all, they are part of the same game. Most likely, each would be configured as a separate project within a single workspace/solution.
- Although you can add multiple projects to a single solution, we generally recommend creating a new workspace or solution for each program, especially while learning. It's simpler and there's less chance of something going wrong.

### Writing your first program
- Skipping this part

### Options: Compile, build, rebuild, clean, and run/start?
- When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn't been modified doesn't need to be recompiled - the cached object file from last time can be used. This can speed up compilation times significantly.
- Build : compiles all modified code files in the project/workspace/solution.
- Clean : removes all cached objects and executables.
- Rebuild : does a clean followed by build.
- Compile : recompiles a single code file (regardless of caching). This option does not invoke the linker or produce an executable.
- Run/start : executes the executable from a prior build. Some IDEs will invoke a build before doing a run.

## Configuring your compiler: Build configurations
- A **build configuration** (also called a **build target**) is a collection of project settings that determines how your IDE will build your project.
- The build configuration typically includes things like what the executable will be named, what directories the IDE will look in for other code and library files, where to keep or strip out debugging info, how much to have the compiler optimize your program, etc.
- When you create a new project in your IDE, most iDEs will set up two different build configurations for you: a release configuration, and a debug configuration.
- The **debug configuration** is designed to help you debug your program, and is generally the one you will use when writing your programs.
	- This config turns off all optimizations, and includes debugging info - which makes your programs larger and slower but much easier to debug.
	- The debug config is usually selected as the active config by default.
- The **release configuration** is designed to be used when releasing your program to the public.
	- This version is typically optimized for size and performance, and doesn't contain the extra debugging info.
	- Because the release config includes all optimizations, this mode is also useful for testing the performance of your code.

## Configuring your compiler: Compiler extensions
- The C++ standard defines rules about how programs should behave in specific circumstances. In most cases, compilers will follow these rules. However, many compilers implement their own changes to the language, often to enhance compatibility with other versions of the language, or for historical reasons. These compiler-specific behaviors are called **compiler extensions**.
- Programs using non-standard extensions generally will not compile on other compilers, and even if they do, they may not run correctly.
- Be warned that compiler extensions are often enabled by default - this is not good for beginners.
- Compiler extensions are never necessary; it's recommended to turn them off.
	- Refer to IDE documentation on how to turn the compiler extensions off.
- Note that these settings are applied on a per-project basis.

## Configuring your compiler: Warning and error levels
- When you write your programs, the compiler will check to ensure you've followed the rules of the C++ language.
	- If any of the rules are violated, the compiler is required to emit a **diagnostic message**.
	- The C++ standard does not define how diagnostics should be categorized or worded. However, there are some common conventions that compilers have adopted.
- If compilation cannot continue due to the violation, then the compiler will emit an error.
- If compilation can continue despite the violation, the compiler may decide to emit either an error or a **warning**. Warnings are similar to errors, but they do not halt compilation.
	- In some cases, the compiler may identify code that does not violate the rules of the language, but that it believes could be incorrect. In such cases, the compiler may decide to emit a warning as a notice to the programmer that something seems amiss.
- In most cases, warnings can be resolved by fixing the issue. In rare cases, it may be necessary to explicitly tell the compiler to not generate a particular warning.
	- C++ does not support an official way to do this, but many compilers offer solutions (via `#pragma` directives).

### Increasing your warning levels
- By default, most compilers will only generate warnings about the most obvious issues. However, you can request your compiler to be more assertive about proving warnings for things it finds strange.
- If you are learning, turn your warning levels up to the maximum.
- For setting up max warning level for Visual Studio (All Configurations):
	- Project Properties > Configuration Properties > C/C++ > General > Warning Level : `Level4 (/W4)`
	  ![[VS-EnableAllWarnings-min.webp]]
	- .. > C/C++ > Command Line > Additional Options : `/w44365` (turns on signed/unsigned conversion warnings)
	- .. > C/C++ > External Includes > External Header Warning Level : `Level3 (/external:W3)`

### Treat warnings as errors
- It is possible to set compiler to treat all warnings as if they were errors; meaning, the compiler will halt if it finds any warnings.
- For Visual Studio:
	- Project Properties > Configuration Properties > C/C++ > General > Treat Warnings As Errors : `Yes (/WX)`
	  ![[Pasted image 20240723145052.png]]


### (personal note) Ignore Warnings
- Setting warning levels to 3~4 and treating warning as error definitely puts a wench in things when libraries are used. Use `#pragma` directive to tell the compiler to ignore warnings from a library, like so:

```c++
#pragma warning(push, 0)
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#pragma warning(pop)
```

## Configuring your compiler: Choosing a language standard
- In professional environments, it's common to chose a language standard that is one or two versions back from the latest standard (e.g. if C++20 is the latest, then C++14 or C++17).
	- This is typically done to ensure the compiler makers have had a chance to resolve defects, and that best practices for new features are well understood.
	- Where relevant, this also helps ensure better cross-platform compatibility, as compilers on some platforms may not provide full support for newer language standards immediately.
- For personal projects and while learning, choosing the latest finalized standard is fine, as there is little downside to doing so.
- This guide recommends using C++17 or higher.

### Setting a language standard in Visual Studio
![[Pasted image 20240723171123.png]]

### Exporting your configuration
- Having to reselect all of the settings each time you make a new project is burdensome - and so most IDEs provide a way to export your settings.
- For Visual Studio, Project > Export Template > Select Project Template, Add name, etc. > Finish
	- Once saved, the template will be shown when you make a new project

## Statements and the structure of a program

### Statements
- A **computer program** is a sequence of instructions that tell the computer what to do.
- A **statement** is a type of instruction that causes the program to perform some action.
- Statements are the smallest independent unit of computation in the C++ language, which makes it the most common type of instruction.
- Most (but not all) statements in C++ end in a semicolon.
- In a high-level language like C++, a single statement may compile into many machine language instructions.
- There are many different kinds of statements in C++:
	- Declaration
	- Jump
	- Expression
	- Compound
	- Selection (conditionals)
	- Iteration (loops)
	- Try
- Statements are typically grouped into units called functions.
- A **function** is a collection of statements that get executed sequentially (top to bottom).
- Every C++ program must have a special function named `main`.
	- Programs typically terminate after the last statement inside `main` function has been executed.
- The name of a function (or object, type, template, etc.) is called its **identifier**.

### Syntax and syntax errors
- The rules that govern how sentences are constructed in a language is called a syntax.
	- If you violate a rule, the compiler will issue you a **syntax error**.
- A common syntax error is when a semicolon is missing at the end of a statement.

## Comments
- A comment is a programmer-readable note that is inserted directly into the source code of the program, which gets ignored by the compiler and are for the programmer's use only.
- Single line comment begins with `//`.
- Multi-line comment begins with `/*` and ends with `*/`.

## Intro to objects and variables
### Data and values
- **Data** is any info that can be moved, processed, or stored by a computer
- A single piece of data is called a **value**.

### Random Access Memory
- The main memory in a computer is called Random Access Memory (RAM). When a program is ran, the OS loads the program into RAM.
- The OS reserves some additional RAM for the program to use while it is running. Common uses for this memory are to store values entered by the user, to store data read in from a file or network, or to store values calculated while the program is running so they can be used again later.

### Objects and variables
- In C++, direct memory access is discouraged. Instead, we access memory through an object.
- An **object** is a region of storage (usually memory) that can store a value, and has other associated properties.
	- How the compiler and OS work to assign memory to objects is beyond the scope of this guide.
- Although objects in C++ can be unnamed (anonymous), more often we name our objects using an identifier. An object with a name is called a **variable**.
- In general programming, the term *object* typically refers to an unnamed object in memory, a variable, or a function. In C++, the term *object* has a narrow definition that excludes functions.\

### Variable instantiation
- In order to create a variable, we use a special kind of declaration statement called a **definition**.
	- Example: `int x;`
- When the program is run (called **runtime**), the variable will be instantiated. **Instantiation** means the object will be created and assigned a memory address.
	- Variables must be instantiated before they can be used to store values.
- An instantiated object is sometimes called an **instance**.

### Data types
- A **data type** determines what kind of value the object will store.
	- Types include `int`, `double`, `float`, `char`, `string`, `bool`, and etc.

### Defining multiple variables
- It is possible to define multiple variables of the same type in a single statement:

```C++
int a;
int b;
int c, d;
```

- Although the language allows it, it is best to avoid defining multiple variables in a single line.

## Variable assignment and initialization

### Variable assignment
- After a variable has been defined, a value can be given to the variable by using the `=` operator. This process is called an **assignment**, and the `=` operator is called the **assignment operator**.
	- Example: `int width; width = 5;`
- By default, assignment copies the value on the right-hand side of the `=` operator to the variable on the left-hand side of the operator. This is called **copy assignment**.

### Initialization
- The process of specifying an initial value for an object is called **initialization**.
- Definition and assignment can be combined into one with initialization.
	- Example: `int width = 5;`
- The syntax used to initialize an object is called an **initializer**

### Different forms of initialization
- There are 6 basic ways to initialize variables in C++:

```C++
int a; // default initialization
int b = 5; // copy initialization
int c(6); // direct init

// List init methods (C++11) (preferred)
int d{7}; // direct list init
int e = {8}; // copy list init
int f{}; // value initialization
```

### Default initialization
- When no initializer is provided, this is called default initialization. In most cases, default init performs no init, and leaves a variable with an indeterminate value (garbage data).

### Copy initialization
- Copy initialization had fallen out of favor in modern C++ due to being less efficient than other forms of init for some complex types. However, C++ remedied the bulk of these issues, and copy init is now finding new advocates.
- Copy init is also used whenever values are implicitly copied or converted, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.

### Direct initialization
- 