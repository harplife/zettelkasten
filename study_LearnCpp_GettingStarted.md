# Getting Started
- Following the guide https://www.learncpp.com

## Introduction to C/C++
### Before C++, there was C
- The C language was developed in 1972 by Dennis Ritchie at Bell Telephone laboratories, primarily as a systems programming language (a language to write operating systems with).
- C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrote most of the Unix operating systems using C (as opposed to Assembly).
	- Unlike Assembly, which produces programs that can only run on specific CPUs, C has excellent portability, allowing Unix to be easily recompiled on many different types of computers.
	- C and Unix had their fortunes tied together.
- In 1978, Brian Kernighan and Dennis Ritchie published a book called "The C Programming Language".
	- This book was commonly known as K&R.
	- This book provided an informal specification for the language and became a de facto standard.
- In 1983, the American National Standards Institute (ANSI) formed a committee to establish a formal standard for C.
	- In 1989, the C89 standard was released. It's more commonly known as ANSI C.
	- In 1990, the International Organization for Standardization (ISO) adopted ANSI C. This became known as C90.
- In 1999, the ISO committee released a new version of C called C99.
	- C99 adopted many features which had already made their way into compilers as extensions, or had been implemented in C++.

### C++
- In 1979, C++ was developed by Bjarne Stroustrup at Bell Labs as an extension to C.
- C++ adds many new feature to the C language, and is perhaps best thought of as a superset of C (though not strictly true).
- C++ is an object-oriented language. More on this will be covered later.
- C++ was standardized in 1998 by the ISO committee.
	- A minor update to the language was released in 2003, called C++03.
- Five major updates to the C++ language (C++11, 14, 17, 20, and 23) have been made since then, each adding additional functionality.
	- C++11 in particular added a huge number of new capabilities, and is widely considered to be the new baseline version of the language.
- Each new formal release of the language is called a **Language Standard** or **Language Specification**.
	- Standards are named after the year they are released in.

### C/C++'s Philosophy
- The underlying design philosophy of C and C++ can be summed up as "Trust the Programmer".
- C++ is designed to allow the programmer a high degree of freedom to do what they want.
	- However, this also means the language often won't stop the programmer from doing things that doesn't make sense.
	- Knowing what shouldn't be done in C/C++ is just as important as knowing what should be done.

>[!important] What is C++ good at?
>C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of application that most likely would be written in C++:
>- Video games
>- Real-time systems (e.g. transportation, manufacturing, etc.)
>- High-performance financial applications
>- Graphical applications and simulations
>- Productivity / office applications
>- Embedded software
>- Audio and video processing
>- AI/ML

## Introduction to C++ development
- There are 7 steps to C++ development:
	1. Define the problem to solve
	2. Design a solution
	3. Write a program that implements the solution
	4. Compile the program
	5. Link object files
	6. Test program
	7. Debug

### Step 4: Compiling your source code
- A C++ compiler is used to compile C++ source code files.
- The C++ compiler sequentially goes through each source code (`.cpp`) file in your program, and does two important tasks:
	- The compiler checks your C++ code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error. The compilation process will also be aborted until the error is fixed.
	- The compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. The object file also contains metadata that is required or useful in subsequent steps.
- Object files are typically named `name.o` or `name.obj`, where the `name` is the same name as the `name.cpp` file it was produced from.
- Installing a compiler will be covered later.

### Step 5: Linking object files and libraries
- After the compiler has successfully finished, another program called the **linker** kicks in.
	- The linker's job is to combine all of the object files and produce the desired output file (typically an executable file). This process is called **linking**.
- The linker has three main functionalities:
	- The linker reads in each of the object files generated by the compiler and makes sure they are valid.
	- The linker ensures all cross-file dependencies are resolved properly. For example, if you define something in one `.cpp` file, and then use it in a different `.cpp` file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you'll get a linker error, and the linking process will abort.
	- The linker also is capable of linking library files. A **library file** is a collection of precompiled code that has been "packaged up" for reuse in other programs.
- C++ comes with an extensive library called the **C++ Standard Library** that provides a set of useful capabilities for use in your programs.
	- Almost every C++ program written utilizes the standard library in some form, so it's very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn't something you need to worry about.
- You can also optionally link other libraries.
- Once the linker has finished linking all the object files and libraries successfully, then you will have an executable file that you can run.

>[!important] Building
>Because there are multiple steps involved, the term **building** is often used to refer to the full process of converting source code files into an executable that can be run. A specific executable produced as the result of building is sometimes called a **build**.
>For complex projects, build automation tools (such as make or build2) are often used to help automate the process of building programs and running automated tests.

### Steps 6 & 7: Testing and Debugging
- You run the executable and see whether it produces the output you were expecting. If not, it's time for some debugging to figure out what's wrong.
- We'll cover more on this topic later on.

>[!important] Integrated Development Environment (IDE)
>Note that steps 3, 4, 5, and 7 all involve software programs that must be installed; such as editor, compiler, linker, and debugger. While you can use separate programs for each of these activities, a software package known as an Integrated Development Environment (IDE) bundles and integrates all of these features together.


## Installing an IDE
- An Integrated Development Environment (IDE) is a piece of software designed to make it easy to develop, build, and debug your programs.
- A typical modern IDE will include:
	- Some way to easily load and save your code files.
	- A code editor that has programming-friendly features, such as line numbering, syntax highlighting and such.
	- A basic build system that will allow you to compile and link your program into an executable, and then run it.
	- An integrated debugger.
	- Some way to install plugins.
- Some C++ IDEs will install and configure a C++ compiler and linker for you. Others will allow you to plug in a compiler and linker of your choice (installed separately).

### Choosing an IDE
- It's recommended to select an IDE that comes with a compiler that supports at least C++17.
- You should NOT be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).
- These are the absolute minimum compiler versions with C++17 support:
	- GCC/G++ 7
	- Clang++ 8
	- Visual Studio 2017 15.7
- This guide recommends using Visual Studio 2022.
- Do not use Visual Studio Code unless you are an experienced user.

## Compiling your first program
- To write a C++ program inside an IDE, we typically start by creating a new project.
- A **project** is a container that holds all of your source code files, images, data files, and etc., that are needed to produce an executable that you can run or use.
- The project also saves various IDE, compiler, and linker settings, as well as remembering where you left off.
- When you choose to compile your program, all of the `.cpp` files in the project will get compiled and linked.
- Each project corresponds to one program.
- Project files are generally IDE specific, so a project created for one IDE will need to be recreated in a different IDE.
	- CMAKE is a tool that's typically used to convert a project from another environment to a project that's suited for the current environment.

### Workspaces / solutions
- When you create a new project for your program, many IDEs will automatically add your project to a "workspace" or a "solution" (the term varies by IDE).
- A **workspace/solution** is a container that can hold one or more related projects.
	- For example, if you were writing a game and wanted to have a separate executable for single player and multiplayer, you'd need to create two projects. It wouldn't make sense for both of these projects to be completely independent - after all, they are part of the same game. Most likely, each would be configured as a separate project within a single workspace/solution.
- Although you can add multiple projects to a single solution, we generally recommend creating a new workspace or solution for each program, especially while learning. It's simpler and there's less chance of something going wrong.

### Writing your first program
- Skipping this part

### Options: Compile, build, rebuild, clean, and run/start?
- When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn't been modified doesn't need to be recompiled - the cached object file from last time can be used. This can speed up compilation times significantly.
- Build : compiles all modified code files in the project/workspace/solution.
- Clean : removes all cached objects and executables.
- Rebuild : does a clean followed by build.
- Compile : recompiles a single code file (regardless of caching). This option does not invoke the linker or produce an executable.
- Run/start : executes the executable from a prior build. Some IDEs will invoke a build before doing a run.

## Configuring your compiler: Build configurations
- A **build configuration** (also called a **build target**) is a collection of project settings that determines how your IDE will build your project.
- The build configuration typically includes things like what the executable will be named, what directories the IDE will look in for other code and library files, where to keep or strip out debugging info, how much to have the compiler optimize your program, etc.
- When you create a new project in your IDE, most iDEs will set up two different build configurations for you: a release configuration, and a debug configuration.
- The **debug configuration** is designed to help you debug your program, and is generally the one you will use when writing your programs.
	- This config turns off all optimizations, and includes debugging info - which makes your programs larger and slower but much easier to debug.
	- The debug config is usually selected as the active config by default.
- The **release configuration** is designed to be used when releasing your program to the public.
	- This version is typically optimized for size and performance, and doesn't contain the extra debugging info.
	- Because the release config includes all optimizations, this mode is also useful for testing the performance of your code.

## Configuring your compiler: Compiler extensions
- The C++ standard defines rules about how programs should behave in specific circumstances. In most cases, compilers will follow these rules. However, many compilers implement their own changes to the language, often to enhance compatibility with other versions of the language, or for historical reasons. These compiler-specific behaviors are called **compiler extensions**.
- Programs using non-standard extensions generally will not compile on other compilers, and even if they do, they may not run correctly.
- Be warned that compiler extensions are often enabled by default - this is not good for beginners.
- Compiler extensions are never necessary; it's recommended to turn them off.
	- Refer to IDE documentation on how to turn the compiler extensions off.
- Note that these settings are applied on a per-project basis.

## Configuring your compiler: Warning and error levels
- When you write your programs, the compiler will check to ensure you've followed the rules of the C++ language.
	- If any of the rules are violated, the compiler is required to emit a **diagnostic message**.
	- The C++ standard does not define how diagnostics should be categorized or worded. However, there are some common conventions that compilers have adopted.
- If compilation cannot continue due to the violation, then the compiler will emit an error.
- If compilation can continue despite the violation, the compiler may decide to emit either an error or a **warning**. Warnings are similar to errors, but they do not halt compilation.
	- In some cases, the compiler may identify code that does not violate the rules of the language, but that it believes could be incorrect. In such cases, the compiler may decide to emit a warning as a notice to the programmer that something seems amiss.
- In most cases, warnings can be resolved by fixing the issue. In rare cases, it may be necessary to explicitly tell the compiler to not generate a particular warning.
	- C++ does not support an official way to do this, but many compilers offer solutions (via `#pragma` directives).

### Increasing your warning levels
- By default, most compilers will only generate warnings about the most obvious issues. However, you can request your compiler to be more assertive about proving warnings for things it finds strange.
- If you are learning, turn your warning levels up to the maximum.
- For setting up max warning level for Visual Studio (All Configurations):
	- Project Properties > Configuration Properties > C/C++ > General > Warning Level : `Level4 (/W4)`
	  ![[VS-EnableAllWarnings-min.webp]]
	- .. > C/C++ > Command Line > Additional Options : `/w44365` (turns on signed/unsigned conversion warnings)
	- .. > C/C++ > External Includes > External Header Warning Level : `Level3 (/external:W3)`

### Treat warnings as errors
- It is possible to set compiler to treat all warnings as if they were errors; meaning, the compiler will halt if it finds any warnings.
- For Visual Studio:
	- Project Properties > Configuration Properties > C/C++ > General > Treat Warnings As Errors : `Yes (/WX)`
	  ![[Pasted image 20240723145052.png]]


### (personal note) Ignore Warnings
- Setting warning levels to 3~4 and treating warning as error definitely puts a wench in things when libraries are used. Use `#pragma` directive to tell the compiler to ignore warnings from a library, like so:

```c++
#pragma warning(push, 0)
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#pragma warning(pop)
```

## Configuring your compiler: Choosing a language standard
- In professional environments, it's common to chose a language standard that is one or two versions back from the latest standard (e.g. if C++20 is the latest, then C++14 or C++17).
	- This is typically done to ensure the compiler makers have had a chance to resolve defects, and that best practices for new features are well understood.
	- Where relevant, this also helps ensure better cross-platform compatibility, as compilers on some platforms may not provide full support for newer language standards immediately.
- For personal projects and while learning, choosing the latest finalized standard is fine, as there is little downside to doing so.
- This guide recommends using C++17 or higher.

### Setting a language standard in Visual Studio
![[Pasted image 20240723171123.png]]

### Exporting your configuration
- Having to reselect all of the settings each time you make a new project is burdensome - and so most IDEs provide a way to export your settings.
- For Visual Studio, Project > Export Template > Select Project Template, Add name, etc. > Finish
	- Once saved, the template will be shown when you make a new project

## Statements and the structure of a program

### Statements
- A **computer program** is a sequence of instructions that tell the computer what to do.
- A **statement** is a type of instruction that causes the program to perform some action.
- Statements are the smallest independent unit of computation in the C++ language, which makes it the most common type of instruction.
- Most (but not all) statements in C++ end in a semicolon.
- In a high-level language like C++, a single statement may compile into many machine language instructions.
- There are many different kinds of statements in C++:
	- Declaration
	- Jump
	- Expression
	- Compound
	- Selection (conditionals)
	- Iteration (loops)
	- Try
- Statements are typically grouped into units called functions.
- A **function** is a collection of statements that get executed sequentially (top to bottom).
- Every C++ program must have a special function named `main`.
	- Programs typically terminate after the last statement inside `main` function has been executed.
- The name of a function (or object, type, template, etc.) is called its **identifier**.

### Syntax and syntax errors
- The rules that govern how sentences are constructed in a language is called a syntax.
	- If you violate a rule, the compiler will issue you a **syntax error**.
- A common syntax error is when a semicolon is missing at the end of a statement.

## Comments
- A comment is a programmer-readable note that is inserted directly into the source code of the program, which gets ignored by the compiler and are for the programmer's use only.
- Single line comment begins with `//`.
- Multi-line comment begins with `/*` and ends with `*/`.

## Intro to objects and variables
### Data and values
- **Data** is any info that can be moved, processed, or stored by a computer
- A single piece of data is called a **value**.

### Random Access Memory
- The main memory in a computer is called Random Access Memory (RAM). When a program is ran, the OS loads the program into RAM.
- The OS reserves some additional RAM for the program to use while it is running. Common uses for this memory are to store values entered by the user, to store data read in from a file or network, or to store values calculated while the program is running so they can be used again later.

### Objects and variables
- In C++, direct memory access is discouraged. Instead, we access memory through an object.
- An **object** is a region of storage (usually memory) that can store a value, and has other associated properties.
	- How the compiler and OS work to assign memory to objects is beyond the scope of this guide.
- Although objects in C++ can be unnamed (anonymous), more often we name our objects using an identifier. An object with a name is called a **variable**.
- In general programming, the term *object* typically refers to an unnamed object in memory, a variable, or a function. In C++, the term *object* has a narrow definition that excludes functions.\

### Variable instantiation
- In order to create a variable, we use a special kind of declaration statement called a **definition**.
	- Example: `int x;`
- When the program is run (called **runtime**), the variable will be instantiated. **Instantiation** means the object will be created and assigned a memory address.
	- Variables must be instantiated before they can be used to store values.
- An instantiated object is sometimes called an **instance**.

### Data types
- A **data type** determines what kind of value the object will store.
	- Types include `int`, `double`, `float`, `char`, `string`, `bool`, and etc.

### Defining multiple variables
- It is possible to define multiple variables of the same type in a single statement:

```C++
int a;
int b;
int c, d;
```

- Although the language allows it, it is best to avoid defining multiple variables in a single line.

## Variable assignment and initialization

### Variable assignment
- After a variable has been defined, a value can be given to the variable by using the `=` operator. This process is called an **assignment**, and the `=` operator is called the **assignment operator**.
	- Example: `int width; width = 5;`
- By default, assignment copies the value on the right-hand side of the `=` operator to the variable on the left-hand side of the operator. This is called **copy assignment**.

### Initialization
- The process of specifying an initial value for an object is called **initialization**.
- Definition and assignment can be combined into one with initialization.
	- Example: `int width = 5;`
- The syntax used to initialize an object is called an **initializer**

### Different forms of initialization
- There are 6 basic ways to initialize variables in C++:

```C++
int a; // default initialization
int b = 5; // copy initialization
int c(6); // direct init

// List init methods (C++11) (preferred)
int d{7}; // direct list init
int e = {8}; // copy list init
int f{}; // value initialization
```

### Default initialization
- When no initializer is provided, this is called default initialization. In most cases, default init performs no init, and leaves a variable with an indeterminate value (garbage data).

### Copy initialization
- Copy initialization had fallen out of favor in modern C++ due to being less efficient than other forms of init for some complex types. However, C++ remedied the bulk of these issues, and copy init is now finding new advocates.
- Copy init is also used whenever values are implicitly copied or converted, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.

### Direct initialization
- **Direct initialization** refers to when an initial value is provided inside parenthesis.
- Direct initialization was initially introduced to allow for more efficient initialization of complex objects. It had fallen out of favor in modern C++, being superseded by list init.
	- Another reason why it had fallen out is because it makes it hard to differentiate variables from functions.
	- List init has a few quirks of its own, and so direct init is once again finding use in certain cases.

### List initialization
- **List initialization (aka uniform initialization/brace initialization)** refers to when curly braces are used; which comes in three forms:

```C++
int width{5};
int height = {6};
int depth{};
```

- Prior to the introduction of list initialization, some types of init required using copy init, and other types of init required using direct init. List init was introduced to provide a more consistent init syntax (which is why it is sometimes called "uniform initialization") that works in most cases.
- List initialization also provides a way to initialize objects with a list of values. More on this later.

### List initialization disallows narrowing conversions
- The primary benefit of list initialization is that "narrowing conversions" are disallowed.
	- Narrowing conversion is a potentially unsafe numeric conversion where the destination type may not be able to hold all the values of the source type (e.g. float to int).
	- For example, `int w1{4.5};` will produce a compile error.
- Note that this restriction on narrowing conversions only applies to the list initialization, not to any subsequent assignments to the variable.
	- For example, `w1 = 4.5;` is allowed.

### Value initialization and zero initialization
- When a variable is initialized using empty braces, **value initialization** takes place. In most cases, value init will init the variable to zero (or empty, if that's more appropriate for a given type).
	- In such cases where zeroing occurs, this is called **zero initialization**.
- Use value initialization if the value is temporary and will be replaced.

### Initialize your variables
- Always initialize your variables upon creation, except in special cases.
	- Bjarne Stroustrup and Herb Sutter says so.

### Ignoring unused variable warning
- In C++17, it's possible to ignore unused variable warning by placing `[[maybe_unused]]` in front of the variable. For example:

```C++
[[maybe_unused]] double pi {3.14};
```

## Introduction to iostream
### The input/output library
- The **input/output library** (io library) is part of the C++ standard library that deals with basic input and output.
- To use the functionality defined within the iostream library, we need to include the iostream header at the top of any code file that uses the content defined in iostream, like so:

```C++
#include <iostream>

// rest of the code
```

### std::cout
- One of the most useful in the iostream is `std::cout`, which allows us to send data to the console to be printed out as text.
	- cout stands for character output.
- A simple program to print out `Hello World!`:

```C++
#include <iostream>

int main()
{
	std::cout << "Hello World!";

	return 0;
}
```

---

The `cout` object in C++ uses the insertion operator (`<<`) as a way to format output. This is part of the design of the C++ Standard Library’s stream I/O facilities.

Here’s why:

1. **Chainability**: The insertion operator returns a reference to the stream, allowing chained insertions into the same stream. For example:
    
    ```cpp
    std::cout << "Hello, " << "World!" << std::endl;
    ```
    
2. **Type Safety**: The insertion operator is overloaded for many different types, ensuring that the correct formatting is used for each type. This makes it safer and easier to use than C-style I/O functions like `printf`, which require the programmer to specify the type of each argument.
    
3. **Extensibility**: You can overload the insertion operator for your own types, allowing them to be printed using the same syntax as built-in types.
    

In essence, the use of the insertion operator with `cout` provides a consistent, type-safe, and extensible interface for formatted output in C++. It’s one of the features that make C++ a powerful and flexible language for a wide range of programming tasks.

---

### std::cout is buffered
- `std::cout` does not sent its output to the console immediately. Instead, the requested output is stored in a region of memory (called a buffer) first, and then the buffer gets flushed out periodically.
	- This means that if your program crashes/aborts/pauses before the buffer is flushed, any output still waiting in the buffer will not be displayed.
- Writing data to a buffer is typically fast, whereas transferring a batch of data to an output device is comparatively slow. Buffering can significantly increase performance by batching multiple output requests together to minimize the number of times output has to be sent to the output device.

### std::endl
- A way to end a line of text and start a new line is to use `std::endl`, like so:

```C++
#include <iostream>

int main()
{
	std::cout << "Hello World!" << std::endl;
	std::cout << "Bye World!" << std::endl;

	return 0;
}
```

console
```text
Hello world!
Bye World!
```

- `std::endl` may not be necessary after the last line, but it is good practice to do so because some OS do not output a new line before showing the command prompt again.
- `std::endl` not only outputs a newline, it also flushes the buffer.

### Newlines
- Another way to end a line and start a new line other than `std::endl`, is to use `\n` within the text.
	- `\n` can be better in situation where multiple lines of text is to be outputted. Because `std::endl` flushes the buffer, it is slow and inefficient - especially so when multiple lines mean multiple flushes (which is unnecessary).
- `\n` can be used, like so:

```C++
#include <iostraem>

int main()
{
	int x = 5;
	std::cout << "x is equal to: " << x << '\n'; // single quoted, by itself
	std::cout << "Yep." << "\n"; // double quoted, by itself
	std::cout << "And that's all, folks!\n"; // double quoted, part of text
}
```

console
```text
x is equal to: 5
Yep.
And that's all, folks!
```

### std::cin
- `std::cin` is another predefined variable in the `iostream` library.
- `std::cin`, which stands for "character input", reads input from keyboard.
- `>>` operator is typically used along side `std::cin`, like so:

```C++
#include <iostream>

int main()
{
    std::cout << "Enter a number: ";

    int x{};
    std::cin >> x;

    std::cout << "You entered " << x << '\n';
    return 0;
}
```

- Note that `std::endl` was not called after `std::cin`; this is due to the user pressing enter key to have their input accepted.
	- If accepting keyboard input without the user having to press enter, there are third party libraries that specialize in Terminal User Interface (TUI); pdcurses, FXTUI, cpp-terminal, or notcurses.

### std::cin is buffered
- Similarly to `std::cout`, the user input is stored inside a buffer for `std::cin` and then extracted with `>>` operator.
- `std::buffer` is buffered because it allows us to separate the entering of input from the extract of input. We can enter input once and then perform multiple extraction request on it.
- Note that extraction stops at space; whatever is left in the buffer will be extracted on the next iteration of `std::cin`. For example:

```C++
#include <iostream>  // for std::cout and std::cin

int main()
{
    std::cout << "Enter two numbers: ";

    int x{};
    std::cin >> x;

    int y{};
    std::cin >> y;

    std::cout << "You entered " << x << " and " << y << '\n';

    return 0;
}
```

Entering `4 5` first will first print out `4`, and then skip the next input. Instead, it will print out `5`.

## Uninitialized variables and undefined behavior

### Uninitialized variables
- A variable that has not been given a known value (through initialization or assignment) is called an **uninitialized variable**.
- This lack of initialization is a performance optimization inherited from C, as it prevents from creating a lot of data to match creation of many variables (like 100,000 or more).
- Best practice is to always initialize your variables; omit the initialization only if it's intentional and purposeful.

>[!warning]
>Some compilers, such as Visual Studio, will initialize the contents of memory to some preset value when you're using a debug build configuration. This will not happen when using a release build configuration. Therefore, do not be confused when uninitialized variable returns a same value (instead of random garbage data).

- Most modern compilers can detect if a variable is being used without being given a value. If they do, they will generally issue a compile-time warning or error.

>[!warning]
>Using uninitialized variables is one of the most common mistakes that novice programmers make. It can also be one of the most challenging to debug because the program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0.

### Undefined behavior
- Undefined behavior (UB) is the result of executing code whose behavior is not well-defined by the C++ language. In this case, the C++ language doesn't have any rules determining what happens if you use the value of a variable that has not been given a known value.
	- Using the value from an uninitialized variable is an example of undefined behavior.
- Code implementing undefined behavior may exhibit any of the following symptoms:
	- Your program produces different results every time it is run.
	- Your program consistently produces the same incorrect result.
	- Your program behaves inconsistently (sometimes produces the correct result, sometimes not).
	- Your program seems like it’s working but produces incorrect results later in the program.
	- Your program crashes, either immediately or later.
	- Your program works on some compilers but not others.
	- Your program works until you change some other seemingly unrelated code.
- The worst is when undefined behavior actually produces the correct behavior.
- Always do what's necessary to avoid undefined behavior.

### Implementation-defined behavior and unspecified behavior
- Implementation-defined behavior means the behavior of some syntax is left up to the implementation (the compiler) to define. Such behaviors must be consistent and documented, but different compilers may produce different results.
- Example:

```C++
#include <iostream>

int main()
{
	std::cout << sizeof(int) << '\n'; // print how many bytes of memory an int value takes

	return 0;
}
```

- Above examples shows that different compilers (sometimes different OS) may treat the size of an integer differently; the printed value may be `4` or `2`.
- Unspecified behavior means the behavior of some syntax is left up to the implementation (the compiler) to define, but such implementation is not required to document the behavior.
- Best practice is to avoid both implementation-defined behavior and unspecified behavior.

## Keywords and naming identifiers
- C++ reserves a set of 92 words (as of C++23) for its own use - called the **keywords**.
	- Keywords include data types like int, float, double, and etc.
	- Keywords include statements like if/else, case/switch, while, and etc.
- For a full list of keywords, refer to https://en.cppreference.com/w/cpp/keyword

### Identifier naming rules
- There's a lot of flexibility when it comes to naming identifiers. However, there are a few rules that must be followed:
	- No keywords
	- Only letters, numbers, and underscore character.
	- Must begin with a letter (lower/upper) or an underscore.
	- Case sensitive

### Identifier naming best practices
- Variable and function name should start with a lower case letter.
- If variable and function name requires multiple words, combine the words together as camelCase or snake_case.
- Note that when working with someone else's code, it's best to match the style of the existing code than to follow the naming convention above.
- Avoid naming identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- Identifiers should make clear what the value they are holding means.
- Good rule of thumb is to make the length of an identifier proportional to how widely it is used.
	- An identifier with a trivial use can have a short name (e.g. such as i).
	- An identifier that is used more broadly (e.g. a function that is called from many places) should have a longer and more descriptive name (e.g. instead of open, try openFileOnDisk).
- In any case, avoid abbreviations.
- Use comments to describe what a variable is going to be used for.

## Whitespace and basic formatting
- Whitespace is a term that refers to characters that are used for formatting purposes, such as spaces, tabs, and newlines.

### Whitespace separation
- Data type and variable name must be whitespace separated.
- Return type and function name must be whitespace separated.
- Single-line comments are terminated by a newline.
- Preprocessor directives must be placed on separate lines.

### Quoted text and whitespace
- Amount of whitespace is taken literally inside quoted text.
- Newlines are not allowed in quoted text.
	- However, newline character `\n` is fine.
- Quoted text separated by nothing but whitespace will be concatenated:

```C++
std::cout << "Hello "
	"world!"; // prints "Hello world!"
```

### Basic formatting
- C++ does not enforce any kind of formatting restrictions on the programmer. Which means whitespace is generally ignored. This means we can use whitespace wherever we like to format our code in order to make it easier to read.
	- Other languages like Python does enforce restrictions. Indentation errors if violation.
- It's fine to use either tabs or spaces for indentation - there is a debate on it.
- Most IDEs will convert a tab to 4 spaces. This is the recommended way.
- There are two conventional styles for function braces:
	- Opening curly brace on the same line as the statement.
	- Opening curly brace on its own line and same indentation with the closing curly brace (recommended).
- Each statement within curly braces should start one tab in from the closing brace of the function it belongs to.
- Lines should be limited to 80 characters or less.
- If a long line is split with an operator (e.g. `<<` or `+`), the operator should be placed at the beginning of the next line:

```C++
std::cout << 3 + 4
    + 5 + 6
    * 7 * 8;
```

- Use whitespace to align values or comments:

```C++
cost          = 57;  // align
pricePerItem  = 24;  // the comments
value         = 5;   // for
numberOfItems = 17;  // readability

// cout lives in the iostream library
std::cout << "Hello world!\n";

// these comments are easier to read
std::cout << "It is very nice to meet you!\n";

// when separated by whitespace
std::cout << "Yeah!\n";
```

- Best practice is to be consistent with whatever style that has already been established.

### Automatic formatting
- Most modern IDEs will help you format your code.
- In Visual Studio, Edit > Advanced > Format Document/Selection (ctrl+k, ctrl+d)

### Style guides
- A **style guide** is a concise, opinionated document containing programming conventions, formatting guidelines, and best practices.
- Some commonly referenced C++ style guides include:
	- [C++ Core Guidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) - maintained by Bjarne Stroustrup and Herb Sutter
	- Google
	- LLVM
	- GCC/GNU

## Intro to literals and operators
- A **literal (literal constant)** is a fixed value that has been inserted directly into the source code.
- Literals and variables both have a value and a type. Unlike a variable, the value of a literal is fixed.
- Refer to this example:

```C++
#include <iostream>

int main()
{
    std::cout << 5 << '\n'; // print the value of a literal

    int x { 5 };
    std::cout << x << '\n'; // print the value of a variable
    return 0;
}
```

- In the above example, both output statements do the same thing (prints 5). But in the case of literal, the value is printed out directly, as opposed to being fetched from the memory.
- Literals are values that are inserted directly into the source code. These values usually appear directly in the executable code (unless they are optimized out).

### Operators and operands
- In mathematics, an **operation** is a process involving zero or more input values (called **operands**) that produces a new value (called an **output value**). The specific operation to be performed is denoted by a symbol called an **operator**.
	- For example, for a statement like `int x = 1 + 2;`, 1 and 2 are operands and the + is the operator.
- Common operators:
	- addition `+`
	- subtraction `-`
	- multiplication `*`
	- division `/`
	- equality `==` / inequality `!=`
	- assignment `=`
	- insertion `<<` / extraction `>>`
- The number of operands that an operator takes as input is called the operator's **arity**.
	- Not a common word, don't use this word willy nilly
- Operators come in four different arities:
	- **Unary** : acts on one operand. For example, given `-5`, the `operator-` takes literal operand `5` and flips its sign to produce new output value `-5`.
	- **Binary** : acts on two operands placed on left and right. For example, given `1 + 2`, the `operator+` takes the left operand `1` and the right operand `2` and outputs `3`. The insertion `<<` and extraction `>>` operators are also binary operators.
	- **Ternary** : acts on three operands. There is only one, which is the conditional operator. This will be covered later.
	- **Nullary** : operators act on zero operands. There is only one, which is the throw operator. This will be covered later.
- Note that some operators have more than one meaning depending on how they are used. For example, `operator-` has two contexts: used in unary form to invert a number's sign, and used in binary form to do subtraction.

### Chaining operators
- Operators can be chained together such that the output of one operator can be used as the input for another operator.
	- For example, given `2 * 3 + 4`, the multiplication goes first (`2 * 3`) and then the result of that is fed to the plus operator (`6 + 4)`.
- The order in which operators execute is a topic that will be covered more later on. For now, it's enough to know that the arithmetic operators execute in the same order as they do in standard math: PEMDAS.
	- Parenthesis > Exponents > Multiplication/Division > Addition/Subtraction
	- "Please Excuse My Dear Aunt Sally"

### Return values and side effects
- Some operators have additional behaviors. An operator (or function) that has some observable effect beyond producing a return value is said to have a **side effect**.
	- For example, given `x = 5;`, the changed value of `x` is observable even after the operator has finished executing.
	- Another example, given `std::cout << 5;`, the number `5` gets printed to console and stays there even if the statement has finished executing.

## Intro to expressions

### Expressions
- An **expression** is a non-empty sequence of literals, variables, operators, and function calls that calculates a single value.
- The process of executing an expression is called **evaluation**.
- When an expression is evaluated, each of the terms inside the expression are evaluated, until a single value remains - referred to as the **result** of the expression.
- Expressions are always evaluated as part of statements.
	- For example, given `int x = 2+3;`, the expression `2+3` is part of a statement that assigns a value to `x`.
	- Above statement broken down into its syntax would look like this: `type identifier operator expression`.
- A statement that consists of an expression followed by a semicolon is called an **expression statement**.
- Expression statement that produces a value only to discard it, is considered useless (some compilers may produce warnings).
- Subexpression : an expression used as an operand.
	- For example, subexpressions of `x = 4 + 5` are `x` and `4 + 5`.
- Full expression : an expression made up of subexpression(s).
	- For example, `2`, `2 + 3`, and `x = 4 + 5` are all full expressions.
- Compound expression : an expression that contains two or more uses of operators.
	- For example, `x = 4 + 5` is a compound expression because it contains `operator=` and `operator+`.

## Intro to functions
- A **function** is a reusable sequence of statements designed to do a particular job.
- Functions that you write yourself are called **user-defined functions**.
- The structure of a function looks like this:

```C++
returnType functionName() // function header
{
	// function body
}
```

- Unlike some other programming languages, C++ does not allow for functions to be defined inside other functions. The following program is NOT legal:

```C++
#include <iostream>

int main()
{
    void foo() // Illegal: this function is nested inside function main()
    {
        std::cout << "foo!\n";
    }

    foo(); // function call to foo()
    return 0;
}
```

- "foo" is a meaningless word that is often used as a placeholder name for a function or variable when the name is unimportant to the demonstration of some concept.
	- Such words are called **metasyntactic variables**, though they're often called **placeholder names** instead.
	- Other common metasyntactic variables include bar, baz, and 3-letter words that end in oo, such as goo, moo, and boo.

## Function return values
### Return values
- A function can return a value or none at all.
- A function has to indicate what type of value will be returned - which is done by setting the function's **return type** which is defined before the function's name.
	- For example, if the function returns an integer value, then `int` needs to be indicated before the function name.
- If the function does not return a value, it has to indicate that it doesn't, which can be done by setting the function's return type as `void`.
	- Do not put a return statement at the end of a void function.
- It's always a good idea to leave a comment indicating what the return values mean.

### Status codes
- The return value from `main()` is sometimes called a **status code (aka exit code)**, which is passed back to the caller of the program to indicate that the program has run successfully (or not).
- If the status code is `0`, then the program ran normally.
	- A non-zero status code is often used to indicate failure.
- The C++ standard only defines the meaning of 3 status codes:
	- `0`
	- `EXIT_SUCCESS`
	- `EXIT_FAILURE`

### A value-returning function / no return value
- A function that returns a value is called a **value-returning function**.
	- Any function that is not `void` function is value-returning.
- A value-returning function MUST return a value of that type, otherwise undefined behavior will result.
- `main()` is the only exception to the rule, where it will implicitly return `0` if a return statement is not provided.

### Functions return a single value
- A value-returning function can only return a single value back to the caller each time it is called.
- Note that the value provided in a return statement doesn't need to be literal - it can be the result of any valid expression, including a variable or even a call to another function that returns a value.
- There are various ways to work around the single value limitation, which will be covered later on.

### Don't Repeat Yourself
- One of the central tenets of good programming and the main point of a function is "Don't Repeat Yourself" (DRY).
	- If it takes several lines of code to complete a task and it needs to be repeated, it's better to turn it into a function so that only one line of code is repeated.
- DRY is meant to be a guideline, not an absolute rule. DRY can harm overall comprehension when code is broken into pieces that are too small.

## Intro to function parameters/arguments
### Function parameters and arguments
- A **function parameter** is a variable used in the header of a function which is initialized with a value provided by the caller of the function.
- For example:

```C++
void printValue(int x)
{
	std::cout << x << std::endl;
}
```

- In the example above, `int x` is the function parameter for the function `printValue()`. 
- An argument is a value that is passed from the caller to the function when a function call is made.
- For example:

```C++
printValue(5);
```

- In the example above, `5` is the argument passed to `printValue()`.

### How parameters and arguments work together
- When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter (using copy initialization). This process is called **pass-by-value**.
	- Function parameters that utilize pass-by-value are called **value parameters**.
- Note that the number of arguments must generally match the number of function parameters. Otherwise, the compiler will throw an error.
- The argument passed to a function can be any valid expression, as the argument is essentially just an initializer for the parameter, and initializers can be any valid expression.

### Using return values as arguments
- A function can be called inside function header, using return values as arguments.
	- For example, `foo(bar());`.

### Unreferenced parameters
- When a parameter is not used inside the function body, compiler sends out a warning that says **unreferenced parameter**.
- In cases where a function parameter needs to exist but is not used in the function body, the name of the function parameter can be omitted (bypasses the warning).
	- A parameter without a name is called an **unnamed parameter**.
	- It's recommended to use a comment to indicate what the name would've been.
	- For example, `void doSomething(int /*count*/);`

## Intro to local scope

### Local variables
- Variables defined inside a function are called **local variables**.
- Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized at the point of definition.
	- Local variables are destroyed in the opposite order of creation.
- An object's **lifetime** is defined to be the time between its creation and destruction.
	- Note that variable creation/destruction happen during runtime, not at compile time. Therefore, lifetime is a runtime property.
- In most cases, the destroyed object becomes invalid, and any further use of the object will result in undefined behavior.
	- At some point after destruction, the memory used by the object will be freed up.

### Local scope
- An identifier's scope determines where the identifier can be seen and used within the source code.
- When an identifier can be seen and used, we say it is **in scope**.
	- When an identifier cannot be seen nor used, we say it is **out of scope**.
- Scope is a compile-time property, and trying to use an identifier outside its scope will result in a compile error.
- Local variables defined in one function are not in scope in other functions.

### Functional separation
- Variables with duplicate names but in different scopes does not conflict with each other - meaning, variable `x` defined in `foo()` is not the same as `x` defined in `bar()`.

### Temporary objects
- A temporary object (aka anonymous object) is an unnamed object that is created by the compiler to store a value temporarily.
- There are many different ways that temporary values can be created. For example:

```C++
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

int main()
{
	std::cout << getValueFromUser() << '\n';

	return 0;
}
```

- In the example above, variable `input` is destroyed at the end of the function, and the caller receives a copy of the value. This copy of the value is stored in a temporary object, which is then passed to `std::cout` to be printed.
- Temporary objects have no scope at all. They are destroyed at the end of the full expression in which they are created.

## Forward declarations and definitions
### Forward declarations
- The compiler compiles the contents of code files sequentially. When the compiler reaches a function that is not defined (before it's called), the compiler will raise an error.
- Having functions defined before it is called is a simple solution for a simple program, but in a larger complex program, it can be tedious trying to figure out which functions call which other functions (in what order).
	- In fact, it becomes a problem when there are two or more functions that call upon each other. For example, if `foo()` calls `bar()` and `bar()` calls `foo()`, there is no way to order the functions to make it work.
- A **forward declaration** allows us to tell the compiler about the existence of an identifier before actually defining the identifier.
	- When the compiler encounters a call to the function that is not yet defined but declared instead, it'll check to make sure the function is being called correctly but won't execute the function call until the function definition is found.
- A **function declaration** (function prototype) is, as it sounds, declaring a function (but without definition). Its statement consists of the function's return type, name, and parameter types, terminated with a semicolon.
	- The function body is not included in the declaration.
	- The function declaration statement must match the function that is defined later on.
	- Forward declaration is simply a function declaration that is done before definition. Think "paying it forward".
- Example of forward declaration:

```C++
#include <iostream>

int add(int x, int y); // forward declaration of add()

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

>[!important]
>Main advantage of using forward declaration is that it allows us to use a function that is defined in a different code file.

### Forgetting the function body
- One of the common mistakes that new programmers do is forgetting to define the function after the forward declaration has been made.
	- In such case, the program may compile and run fine as long as the function is not called. However, if the function is called, the linker will raise error.

### Declarations vs. definitions
- A **declaration** tells the compiler about the existence of an identifier and its associated type information.
	- Example: `int add(int x, int y);`, `int x;`
- A **definition** is a declaration that actually implements or instantiates the identifier.
	- Note that `int x;` is both a definition and a declaration.
- Declarations that aren't definitions are called **pure declarations**.
	- In common language, the term declaration is typically used to mean a pure declaration, and a definition is used to mean a definition that also serves as a declaration.

### The one definition rule (ODR)
- The one definition rule (ODR) is a well-known rule in C++ that consists of three parts:
	- Within a file, each function, variable, type or template in a given scope can only have one definition. Definitions occurring in different scopes do not violate this rule.
	- Within a program, each function or variable in a given scope can only have one definition. This rule exists because programs can have more than one file. Functions and variables not visible to the linker are excluded from this rule.
	- Types, templates, inline functions, and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical.
- Violating part 1 of the ODR will cause the compiler to issue a redefinition error.
- Violating ODR part 2 will cause the linker to issue a redefinition error.
- Violating ODR part 3 will cause undefined behavior.
- Functions that share an identifier but have different sets of parameters are considered to be distinct functions. This is called **overloading**, and such definitions do not violate the ODR. More on this topic discussed later on.

## Programs with multiple code files
- As programs get larger, it is common to split them into multiple files for organizational or reusability purposes.
- IDEs provide functionalities to manage files in a project.
- The compiler compiles each file individually. It does not know about the contents of other code files, or remember anything it has been from previously compiled code files.
- The limited visibility and short memory is intentional, for a few reasons:
	- It allows the source files of a project to be compiled in any order.
	- When we change a source file, only that source file needs to be recompiled.
	- It reduces the possibility of naming conflicts between identifiers in different files.
- In order to call a function that is defined in another file, forward declaration of the function needs to be made (in current file).

>[!warning]
>Even if you create a file in the same project folder via File Explorer (Windows), some IDEs may ignore that file. It's best to create to create a new file by using the IDE, or add the file to the project manually.

## Naming collisions and an introduction to namespaces

### Naming collisions
- When a compiler or linker can't tell apart two identical identifiers, they will produce an error - referred to as **naming collision/conflict**.
	- Note that this error will occur even if these two functions are defined in separate files.
	- This error will occur even if the function is not called.

### Namespaces
- A namespace provides another type of scope region (called **namespace scope**) that allows you to declare names inside of it for the purpose of disambiguation. Any names declared inside the namespace won't be mistaken for identical names in other scopes.
- Only declarations and definitions can appear in the scope of a namespace (not executable statements).
- Namespaces are often used to group related identifiers in a large project to help ensure they don't inadvertently collide with other identifiers.

### The global namespace
- Any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly-defined namespace called the **global namespace (global scope)**.
- `main()` is defined inside the global namespace.
- Although variables can be defined in the global namespace, this should generally be avoided.

---

There are several ways for multiple functions to share a variable without using a global variable in C++. Here are a few methods:

1. **Passing by Reference**: You can pass the variable as a reference to the functions that need to access or modify it. This allows the functions to share the same variable.
    ```cpp
    void func1(int& x) {
        x += 5;
    }

    void func2(int& x) {
        x *= 2;
    }

    int main() {
        int a = 10;
        func1(a);
        func2(a);
        std::cout << a << std::endl; // Outputs 30
        return 0;
    }
    ```

2. **Static Local Variables**: You can declare a variable as `static` inside a function. A static local variable retains its value between function calls and is shared by all calls to that function.
    ```cpp
    void func() {
        static int x = 0;
        x += 5;
        std::cout << x << std::endl;
    }

    int main() {
        func(); // Outputs 5
        func(); // Outputs 10
        return 0;
    }
    ```

3. **Class Members**: If the functions are methods of the same class, they can share a variable by making it a member of the class.
    ```cpp
    class MyClass {
    public:
        int x;

        void func1() {
            x += 5;
        }

        void func2() {
            x *= 2;
        }
    };

    int main() {
        MyClass obj;
        obj.x = 10;
        obj.func1();
        obj.func2();
        std::cout << obj.x << std::endl; // Outputs 30
        return 0;
    }
    ```

Remember, each of these methods has its own use cases and trade-offs. It's important to choose the one that best fits your needs based on the specific requirements of your program.

---

