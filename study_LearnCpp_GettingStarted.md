# Getting Started
- Following the guide https://www.learncpp.com

## Introduction to C/C++
### Before C++, there was C
- The C language was developed in 1972 by Dennis Ritchie at Bell Telephone laboratories, primarily as a systems programming language (a language to write operating systems with).
- C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrote most of the Unix operating systems using C (as opposed to Assembly).
	- Unlike Assembly, which produces programs that can only run on specific CPUs, C has excellent portability, allowing Unix to be easily recompiled on many different types of computers.
	- C and Unix had their fortunes tied together.
- In 1978, Brian Kernighan and Dennis Ritchie published a book called "The C Programming Language".
	- This book was commonly known as K&R.
	- This book provided an informal specification for the language and became a de facto standard.
- In 1983, the American National Standards Institute (ANSI) formed a committee to establish a formal standard for C.
	- In 1989, the C89 standard was released. It's more commonly known as ANSI C.
	- In 1990, the International Organization for Standardization (ISO) adopted ANSI C. This became known as C90.
- In 1999, the ISO committee released a new version of C called C99.
	- C99 adopted many features which had already made their way into compilers as extensions, or had been implemented in C++.

### C++
- In 1979, C++ was developed by Bjarne Stroustrup at Bell Labs as an extension to C.
- C++ adds many new feature to the C language, and is perhaps best thought of as a superset of C (though not strictly true).
- C++ is an object-oriented language. More on this will be covered later.
- C++ was standardized in 1998 by the ISO committee.
	- A minor update to the language was released in 2003, called C++03.
- Five major updates to the C++ language (C++11, 14, 17, 20, and 23) have been made since then, each adding additional functionality.
	- C++11 in particular added a huge number of new capabilities, and is widely considered to be the new baseline version of the language.
- Each new formal release of the language is called a **Language Standard** or **Language Specification**.
	- Standards are named after the year they are released in.

### C/C++'s Philosophy
- The underlying design philosophy of C and C++ can be summed up as "Trust the Programmer".
- C++ is designed to allow the programmer a high degree of freedom to do what they want.
	- However, this also means the language often won't stop the programmer from doing things that doesn't make sense.
	- Knowing what shouldn't be done in C/C++ is just as important as knowing what should be done.

>[!important] What is C++ good at?
>C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of application that most likely would be written in C++:
>- Video games
>- Real-time systems (e.g. transportation, manufacturing, etc.)
>- High-performance financial applications
>- Graphical applications and simulations
>- Productivity / office applications
>- Embedded software
>- Audio and video processing
>- AI/ML

## Introduction to C++ development
- There are 7 steps to C++ development:
	1. Define the problem to solve
	2. Design a solution
	3. Write a program that implements the solution
	4. Compile the program
	5. Link object files
	6. Test program
	7. Debug

### Step 4: Compiling your source code
- A C++ compiler is used to compile C++ source code files.
- The C++ compiler sequentially goes through each source code (`.cpp`) file in your program, and does two important tasks:
	- The compiler checks your C++ code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error. The compilation process will also be aborted until the error is fixed.
	- The compiler translates your C++ code into machine language instructions. These instructions are stored in an intermediate file called an **object file**. The object file also contains metadata that is required or useful in subsequent steps.
- Object files are typically named `name.o` or `name.obj`, where the `name` is the same name as the `name.cpp` file it was produced from.
- Installing a compiler will be covered later.

### Step 5: Linking object files and libraries
- After the compiler has successfully finished, another program called the **linker** kicks in.
	- The linker's job is to combine all of the object files and produce the desired output file (typically an executable file). This process is called **linking**.
- The linker has three main functionalities:
	- The linker reads in each of the object files generated by the compiler and makes sure they are valid.
	- The linker ensures all cross-file dependencies are resolved properly. For example, if you define something in one `.cpp` file, and then use it in a different `.cpp` file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you'll get a linker error, and the linking process will abort.
	- The linker also is capable of linking library files. A **library file** is a collection of precompiled code that has been "packaged up" for reuse in other programs.
- C++ comes with an extensive library called the **C++ Standard Library** that provides a set of useful capabilities for use in your programs.
	- Almost every C++ program written utilizes the standard library in some form, so it's very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn't something you need to worry about.
- You can also optionally link other libraries.
- Once the linker has finished linking all the object files and libraries successfully, then you will have an executable file that you can run.

>[!important] Building
>Because there are multiple steps involved, the term **building** is often used to refer to the full process of converting source code files into an executable that can be run. A specific executable produced as the result of building is sometimes called a **build**.
>For complex projects, build automation tools (such as make or build2) are often used to help automate the process of building programs and running automated tests.

### Steps 6 & 7: Testing and Debugging
- You run the executable and see whether it produces the output you were expecting. If not, it's time for some debugging to figure out what's wrong.
- We'll cover more on this topic later on.

>[!important] Integrated Development Environment (IDE)
>Note that steps 3, 4, 5, and 7 all involve software programs that must be installed; such as editor, compiler, linker, and debugger. While you can use separate programs for each of these activities, a software package known as an Integrated Development Environment (IDE) bundles and integrates all of these features together.


## Installing an IDE
- An Integrated Development Environment (IDE) is a piece of software designed to make it easy to develop, build, and debug your programs.
- A typical modern IDE will include:
	- Some way to easily load and save your code files.
	- A code editor that has programming-friendly features, such as line numbering, syntax highlighting and such.
	- A basic build system that will allow you to compile and link your program into an executable, and then run it.
	- An integrated debugger.
	- Some way to install plugins.
- Some C++ IDEs will install and configure a C++ compiler and linker for you. Others will allow you to plug in a compiler and linker of your choice (installed separately).

### Choosing an IDE
- It's recommended to select an IDE that comes with a compiler that supports at least C++17.
- You should NOT be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).
- These are the absolute minimum compiler versions with C++17 support:
	- GCC/G++ 7
	- Clang++ 8
	- Visual Studio 2017 15.7
- This guide recommends using Visual Studio 2022.
- Do not use Visual Studio Code unless you are an experienced user.

## Compiling your first program
- To write a C++ program inside an IDE, we typically start by creating a new project.
- A **project** is a container that holds all of your source code files, images, data files, and etc., that are needed to produce an executable that you can run or use.
- The project also saves various IDE, compiler, and linker settings, as well as remembering where you left off.
- When you choose to compile your program, all of the `.cpp` files in the project will get compiled and linked.
- Each project corresponds to one program.
- Project files are generally IDE specific, so a project created for one IDE will need to be recreated in a different IDE.
	- CMAKE is a tool that's typically used to convert a project from another environment to a project that's suited for the current environment.

### Workspaces / solutions
- When you create a new project for your program, many IDEs will automatically add your project to a "workspace" or a "solution" (the term varies by IDE).
- A **workspace/solution** is a container that can hold one or more related projects.
	- For example, if you were writing a game and wanted to have a separate executable for single player and multiplayer, you'd need to create two projects. It wouldn't make sense for both of these projects to be completely independent - after all, they are part of the same game. Most likely, each would be configured as a separate project within a single workspace/solution.
- Although you can add multiple projects to a single solution, we generally recommend creating a new workspace or solution for each program, especially while learning. It's simpler and there's less chance of something going wrong.

### Writing your first program
- Skipping this part

### Options: Compile, build, rebuild, clean, and run/start?
- When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn't been modified doesn't need to be recompiled - the cached object file from last time can be used. This can speed up compilation times significantly.
- Build : compiles all modified code files in the project/workspace/solution.
- Clean : removes all cached objects and executables.
- Rebuild : does a clean followed by build.
- Compile : recompiles a single code file (regardless of caching). This option does not invoke the linker or produce an executable.
- Run/start : executes the executable from a prior build. Some IDEs will invoke a build before doing a run.

## Configuring your compiler: Build configurations
- A **build configuration** (also called a **build target**) is a collection of project settings that determines how your IDE will build your project.
- The build configuration typically includes things like what the executable will be named, what directories the IDE will look in for other code and library files, where to keep or strip out debugging info, how much to have the compiler optimize your program, etc.
- When you create a new project in your IDE, most iDEs will set up two different build configurations for you: a release configuration, and a debug configuration.
- The **debug configuration** is designed to help you debug your program, and is generally the one you will use when writing your programs.
	- This config turns off all optimizations, and includes debugging info - which makes your programs larger and slower but much easier to debug.
	- The debug config is usually selected as the active config by default.
- The **release configuration** is designed to be used when releasing your program to the public.
	- This version is typically optimized for size and performance, and doesn't contain the extra debugging info.
	- Because the release config includes all optimizations, this mode is also useful for testing the performance of your code.

## Configuring your compiler: Compiler extensions
- The C++ standard defines rules about how programs should behave in specific circumstances. In most cases, compilers will follow these rules. However, many compilers implement their own changes to the language, often to enhance compatibility with other versions of the language, or for historical reasons. These compiler-specific behaviors are called **compiler extensions**.
- Programs using non-standard extensions generally will not compile on other compilers, and even if they do, they may not run correctly.
- Be warned that compiler extensions are often enabled by default - this is not good for beginners.
- Compiler extensions are never necessary; it's recommended to turn them off.
	- Refer to IDE documentation on how to turn the compiler extensions off.
- Note that these settings are applied on a per-project basis.

## Configuring your compiler: Warning and error levels
- When you write your programs, the compiler will check to ensure you've followed the rules of the C++ language.
	- If any of the rules are violated, the compiler is required to emit a **diagnostic message**.
	- The C++ standard does not define how diagnostics should be categorized or worded. However, there are some common conventions that compilers have adopted.
- If compilation cannot continue due to the violation, then the compiler will emit an error.
- If compilation can continue despite the violation, the compiler may decide to emit either an error or a **warning**. Warnings are similar to errors, but they do not halt compilation.
	- In some cases, the compiler may identify code that does not violate the rules of the language, but that it believes could be incorrect. In such cases, the compiler may decide to emit a warning as a notice to the programmer that something seems amiss.
- In most cases, warnings can be resolved by fixing the issue. In rare cases, it may be necessary to explicitly tell the compiler to not generate a particular warning.
	- C++ does not support an official way to do this, but many compilers offer solutions (via `#pragma` directives).

### Increasing your warning levels
- By default, most compilers will only generate warnings about the most obvious issues. However, you can request your compiler to be more assertive about proving warnings for things it finds strange.
- If you are learning, turn your warning levels up to the maximum.
- For setting up max warning level for Visual Studio (All Configurations):
	- Project Properties > Configuration Properties > C/C++ > General > Warning Level : `Level4 (/W4)`
	  ![[VS-EnableAllWarnings-min.webp]]
	- .. > C/C++ > Command Line > Additional Options : `/w44365` (turns on signed/unsigned conversion warnings)
	- .. > C/C++ > External Includes > External Header Warning Level : `Level3 (/external:W3)`

### Treat warnings as errors
- It is possible to set compiler to treat all warnings as if they were errors; meaning, the compiler will halt if it finds any warnings.
- For Visual Studio:
	- Project Properties > Configuration Properties > C/C++ > General > Treat Warnings As Errors : `Yes (/WX)`
	  ![[Pasted image 20240723145052.png]]


### (personal note) Ignore Warnings
- Setting warning levels to 3~4 and treating warning as error definitely puts a wench in things when libraries are used. Use `#pragma` directive to tell the compiler to ignore warnings from a library, like so:

```c++
#pragma warning(push, 0)
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#pragma warning(pop)
```

## Configuring your compiler: Choosing a language standard
- In professional environments, it's common to chose a language standard that is one or two versions back from the latest standard (e.g. if C++20 is the latest, then C++14 or C++17).
	- This is typically done to ensure the compiler makers have had a chance to resolve defects, and that best practices for new features are well understood.
	- Where relevant, this also helps ensure better cross-platform compatibility, as compilers on some platforms may not provide full support for newer language standards immediately.
- For personal projects and while learning, choosing the latest finalized standard is fine, as there is little downside to doing so.
- This guide recommends using C++17 or higher.

### Setting a language standard in Visual Studio
![[Pasted image 20240723171123.png]]

### Exporting your configuration
- Having to reselect all of the settings each time you make a new project is burdensome - and so most IDEs provide a way to export your settings.
- For Visual Studio, Project > Export Template > Select Project Template, Add name, etc. > Finish
	- Once saved, the template will be shown when you make a new project

## Statements and the structure of a program

### Statements
- A **computer program** is a sequence of instructions that tell the computer what to do.
- A **statement** is a type of instruction that causes the program to perform some action.
- Statements are the smallest independent unit of computation in the C++ language, which makes it the most common type of instruction.
- Most (but not all) statements in C++ end in a semicolon.
- In a high-level language like C++, a single statement may compile into many machine language instructions.
- There are many different kinds of statements in C++:
	- Declaration
	- Jump
	- Expression
	- Compound
	- Selection (conditionals)
	- Iteration (loops)
	- Try
- Statements are typically grouped into units called functions.
- A **function** is a collection of statements that get executed sequentially (top to bottom).
- Every C++ program must have a special function named `main`.
	- Programs typically terminate after the last statement inside `main` function has been executed.
- The name of a function (or object, type, template, etc.) is called its **identifier**.

### Syntax and syntax errors
- The rules that govern how sentences are constructed in a language is called a syntax.
	- If you violate a rule, the compiler will issue you a **syntax error**.
- A common syntax error is when a semicolon is missing at the end of a statement.

## Comments
- A comment is a programmer-readable note that is inserted directly into the source code of the program, which gets ignored by the compiler and are for the programmer's use only.
- Single line comment begins with `//`.
- Multi-line comment begins with `/*` and ends with `*/`.

## Intro to objects and variables
### Data and values
- **Data** is any info that can be moved, processed, or stored by a computer
- A single piece of data is called a **value**.

### Random Access Memory
- The main memory in a computer is called Random Access Memory (RAM). When a program is ran, the OS loads the program into RAM.
- The OS reserves some additional RAM for the program to use while it is running. Common uses for this memory are to store values entered by the user, to store data read in from a file or network, or to store values calculated while the program is running so they can be used again later.

### Objects and variables
- In C++, direct memory access is discouraged. Instead, we access memory through an object.
- An **object** is a region of storage (usually memory) that can store a value, and has other associated properties.
	- How the compiler and OS work to assign memory to objects is beyond the scope of this guide.
- Although objects in C++ can be unnamed (anonymous), more often we name our objects using an identifier. An object with a name is called a **variable**.
- In general programming, the term *object* typically refers to an unnamed object in memory, a variable, or a function. In C++, the term *object* has a narrow definition that excludes functions.\

### Variable instantiation
- In order to create a variable, we use a special kind of declaration statement called a **definition**.
	- Example: `int x;`
- When the program is run (called **runtime**), the variable will be instantiated. **Instantiation** means the object will be created and assigned a memory address.
	- Variables must be instantiated before they can be used to store values.
- An instantiated object is sometimes called an **instance**.

### Data types
- A **data type** determines what kind of value the object will store.
	- Types include `int`, `double`, `float`, `char`, `string`, `bool`, and etc.

### Defining multiple variables
- It is possible to define multiple variables of the same type in a single statement:

```C++
int a;
int b;
int c, d;
```

- Although the language allows it, it is best to avoid defining multiple variables in a single line.

## Variable assignment and initialization

### Variable assignment
- After a variable has been defined, a value can be given to the variable by using the `=` operator. This process is called an **assignment**, and the `=` operator is called the **assignment operator**.
	- Example: `int width; width = 5;`
- By default, assignment copies the value on the right-hand side of the `=` operator to the variable on the left-hand side of the operator. This is called **copy assignment**.

### Initialization
- The process of specifying an initial value for an object is called **initialization**.
- Definition and assignment can be combined into one with initialization.
	- Example: `int width = 5;`
- The syntax used to initialize an object is called an **initializer**

### Different forms of initialization
- There are 6 basic ways to initialize variables in C++:

```C++
int a; // default initialization
int b = 5; // copy initialization
int c(6); // direct init

// List init methods (C++11) (preferred)
int d{7}; // direct list init
int e = {8}; // copy list init
int f{}; // value initialization
```

### Default initialization
- When no initializer is provided, this is called default initialization. In most cases, default init performs no init, and leaves a variable with an indeterminate value (garbage data).

### Copy initialization
- Copy initialization had fallen out of favor in modern C++ due to being less efficient than other forms of init for some complex types. However, C++ remedied the bulk of these issues, and copy init is now finding new advocates.
- Copy init is also used whenever values are implicitly copied or converted, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.

### Direct initialization
- **Direct initialization** refers to when an initial value is provided inside parenthesis.
- Direct initialization was initially introduced to allow for more efficient initialization of complex objects. It had fallen out of favor in modern C++, being superseded by list init.
	- Another reason why it had fallen out is because it makes it hard to differentiate variables from functions.
	- List init has a few quirks of its own, and so direct init is once again finding use in certain cases.

### List initialization
- **List initialization (aka uniform initialization/brace initialization)** refers to when curly braces are used; which comes in three forms:

```C++
int width{5};
int height = {6};
int depth{};
```

- Prior to the introduction of list initialization, some types of init required using copy init, and other types of init required using direct init. List init was introduced to provide a more consistent init syntax (which is why it is sometimes called "uniform initialization") that works in most cases.
- List initialization also provides a way to initialize objects with a list of values. More on this later.

### List initialization disallows narrowing conversions
- The primary benefit of list initialization is that "narrowing conversions" are disallowed.
	- Narrowing conversion is a potentially unsafe numeric conversion where the destination type may not be able to hold all the values of the source type (e.g. float to int).
	- For example, `int w1{4.5};` will produce a compile error.
- Note that this restriction on narrowing conversions only applies to the list initialization, not to any subsequent assignments to the variable.
	- For example, `w1 = 4.5;` is allowed.

### Value initialization and zero initialization
- When a variable is initialized using empty braces, **value initialization** takes place. In most cases, value init will init the variable to zero (or empty, if that's more appropriate for a given type).
	- In such cases where zeroing occurs, this is called **zero initialization**.
- Use value initialization if the value is temporary and will be replaced.

### Initialize your variables
- Always initialize your variables upon creation, except in special cases.
	- Bjarne Stroustrup and Herb Sutter says so.

### Ignoring unused variable warning
- In C++17, it's possible to ignore unused variable warning by placing `[[maybe_unused]]` in front of the variable. For example:

```C++
[[maybe_unused]] double pi {3.14};
```

## Introduction to iostream
### The input/output library
- The **input/output library** (io library) is part of the C++ standard library that deals with basic input and output.
- To use the functionality defined within the iostream library, we need to include the iostream header at the top of any code file that uses the content defined in iostream, like so:

```C++
#include <iostream>

// rest of the code
```

### std::cout
- One of the most useful in the iostream is `std::cout`, which allows us to send data to the console to be printed out as text.
	- cout stands for character output.
- A simple program to print out `Hello World!`:

```C++
#include <iostream>

int main()
{
	std::cout << "Hello World!";

	return 0;
}
```

---

The `cout` object in C++ uses the insertion operator (`<<`) as a way to format output. This is part of the design of the C++ Standard Library’s stream I/O facilities.

Here’s why:

1. **Chainability**: The insertion operator returns a reference to the stream, allowing chained insertions into the same stream. For example:
    
    ```cpp
    std::cout << "Hello, " << "World!" << std::endl;
    ```
    
2. **Type Safety**: The insertion operator is overloaded for many different types, ensuring that the correct formatting is used for each type. This makes it safer and easier to use than C-style I/O functions like `printf`, which require the programmer to specify the type of each argument.
    
3. **Extensibility**: You can overload the insertion operator for your own types, allowing them to be printed using the same syntax as built-in types.
    

In essence, the use of the insertion operator with `cout` provides a consistent, type-safe, and extensible interface for formatted output in C++. It’s one of the features that make C++ a powerful and flexible language for a wide range of programming tasks.

---

### std::cout is buffered
- `std::cout` does not sent its output to the console immediately. Instead, the requested output is stored in a region of memory (called a buffer) first, and then the buffer gets flushed out periodically.
	- This means that if your program crashes/aborts/pauses before the buffer is flushed, any output still waiting in the buffer will not be displayed.
- Writing data to a buffer is typically fast, whereas transferring a batch of data to an output device is comparatively slow. Buffering can significantly increase performance by batching multiple output requests together to minimize the number of times output has to be sent to the output device.

### std::endl
- A way to end a line of text and start a new line is to use `std::endl`, like so:

```C++
#include <iostream>

int main()
{
	std::cout << "Hello World!" << std::endl;
	std::cout << "Bye World!" << std::endl;

	return 0;
}
```

console
```text
Hello world!
Bye World!
```

- `std::endl` may not be necessary after the last line, but it is good practice to do so because some OS do not output a new line before showing the command prompt again.
- `std::endl` not only outputs a newline, it also flushes the buffer.

### Newlines
- Another way to end a line and start a new line other than `std::endl`, is to use `\n` within the text.
	- `\n` can be better in situation where multiple lines of text is to be outputted. Because `std::endl` flushes the buffer, it is slow and inefficient - especially so when multiple lines mean multiple flushes (which is unnecessary).
- `\n` can be used, like so:

```C++
#include <iostraem>

int main()
{
	int x = 5;
	std::cout << "x is equal to: " << x << '\n'; // single quoted, by itself
	std::cout << "Yep." << "\n"; // double quoted, by itself
	std::cout << "And that's all, folks!\n"; // double quoted, part of text
}
```

console
```text
x is equal to: 5
Yep.
And that's all, folks!
```

### std::cin
- `std::cin` is another predefined variable in the `iostream` library.
- `std::cin`, which stands for "character input", reads input from keyboard.
- `>>` operator is typically used along side `std::cin`, like so:

```C++
#include <iostream>

int main()
{
    std::cout << "Enter a number: ";

    int x{};
    std::cin >> x;

    std::cout << "You entered " << x << '\n';
    return 0;
}
```

- Note that `std::endl` was not called after `std::cin`; this is due to the user pressing enter key to have their input accepted.
	- If accepting keyboard input without the user having to press enter, there are third party libraries that specialize in Terminal User Interface (TUI); pdcurses, FXTUI, cpp-terminal, or notcurses.

### std::cin is buffered
- Similarly to `std::cout`, the user input is stored inside a buffer for `std::cin` and then extracted with `>>` operator.
- `std::buffer` is buffered because it allows us to separate the entering of input from the extract of input. We can enter input once and then perform multiple extraction request on it.
- Note that extraction stops at space; whatever is left in the buffer will be extracted on the next iteration of `std::cin`. For example:

```C++
#include <iostream>  // for std::cout and std::cin

int main()
{
    std::cout << "Enter two numbers: ";

    int x{};
    std::cin >> x;

    int y{};
    std::cin >> y;

    std::cout << "You entered " << x << " and " << y << '\n';

    return 0;
}
```

Entering `4 5` first will first print out `4`, and then skip the next input. Instead, it will print out `5`.

## Uninitialized variables and undefined behavior

### Uninitialized variables
- A variable that has not been given a known value (through initialization or assignment) is called an **uninitialized variable**.
- This lack of initialization is a performance optimization inherited from C, as it prevents from creating a lot of data to match creation of many variables (like 100,000 or more).
- Best practice is to always initialize your variables; omit the initialization only if it's intentional and purposeful.

>[!warning]
>Some compilers, such as Visual Studio, will initialize the contents of memory to some preset value when you're using a debug build configuration. This will not happen when using a release build configuration. Therefore, do not be confused when uninitialized variable returns a same value (instead of random garbage data).

- Most modern compilers can detect if a variable is being used without being given a value. If they do, they will generally issue a compile-time warning or error.

>[!warning]
>Using uninitialized variables is one of the most common mistakes that novice programmers make. It can also be one of the most challenging to debug because the program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0.

### Undefined behavior
- Undefined behavior (UB) is the result of executing code whose behavior is not well-defined by the C++ language. In this case, the C++ language doesn't have any rules determining what happens if you use the value of a variable that has not been given a known value.
	- Using the value from an uninitialized variable is an example of undefined behavior.
- Code implementing undefined behavior may exhibit any of the following symptoms:
	- Your program produces different results every time it is run.
	- Your program consistently produces the same incorrect result.
	- Your program behaves inconsistently (sometimes produces the correct result, sometimes not).
	- Your program seems like it’s working but produces incorrect results later in the program.
	- Your program crashes, either immediately or later.
	- Your program works on some compilers but not others.
	- Your program works until you change some other seemingly unrelated code.
- The worst is when undefined behavior actually produces the correct behavior.
- Always do what's necessary to avoid undefined behavior.

### Implementation-defined behavior and unspecified behavior
- Implementation-defined behavior means the behavior of some syntax is left up to the implementation (the compiler) to define. Such behaviors must be consistent and documented, but different compilers may produce different results.
- Example:

```C++
#include <iostream>

int main()
{
	std::cout << sizeof(int) << '\n'; // print how many bytes of memory an int value takes

	return 0;
}
```

- Above examples shows that different compilers (sometimes different OS) may treat the size of an integer differently; the printed value may be `4` or `2`.
- Unspecified behavior means the behavior of some syntax is left up to the implementation (the compiler) to define, but such implementation is not required to document the behavior.
- Best practice is to avoid both implementation-defined behavior and unspecified behavior.

## Keywords and naming identifiers
- C++ reserves a set of 92 words (as of C++23) for its own use - called the **keywords**.
	- Keywords include data types like int, float, double, and etc.
	- Keywords include statements like if/else, case/switch, while, and etc.
- For a full list of keywords, refer to https://en.cppreference.com/w/cpp/keyword

### Identifier naming rules
- There's a lot of flexibility when it comes to naming identifiers. However, there are a few rules that must be followed:
	- No keywords
	- Only letters, numbers, and underscore character.
	- Must begin with a letter (lower/upper) or an underscore.
	- Case sensitive

### Identifier naming best practices
- Variable and function name should start with a lower case letter.
- If variable and function name requires multiple words, combine the words together as camelCase or snake_case.
- Note that when working with someone else's code, it's best to match the style of the existing code than to follow the naming convention above.
- Avoid naming identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- Identifiers should make clear what the value they are holding means.
- Good rule of thumb is to make the length of an identifier proportional to how widely it is used.
	- An identifier with a trivial use can have a short name (e.g. such as i).
	- An identifier that is used more broadly (e.g. a function that is called from many places) should have a longer and more descriptive name (e.g. instead of open, try openFileOnDisk).
- In any case, avoid abbreviations.
- Use comments to describe what a variable is going to be used for.

## Whitespace and basic formatting
- Whitespace is a term that refers to characters that are used for formatting purposes, such as spaces, tabs, and newlines.

### Whitespace separation
- Data type and variable name must be whitespace separated.
- Return type and function name must be whitespace separated.
- Single-line comments are terminated by a newline.
- Preprocessor directives must be placed on separate lines.

### Quoted text and whitespace
- Amount of whitespace is taken literally inside quoted text.
- Newlines are not allowed in quoted text.
	- However, newline character `\n` is fine.
- Quoted text separated by nothing but whitespace will be concatenated:

```C++
std::cout << "Hello "
	"world!"; // prints "Hello world!"
```

### Basic formatting
- C++ does not enforce any kind of formatting restrictions on the programmer. Which means whitespace is generally ignored. This means we can use whitespace wherever we like to format our code in order to make it easier to read.
	- Other languages like Python does enforce restrictions. Indentation errors if violation.
- It's fine to use either tabs or spaces for indentation - there is a debate on it.
- Most IDEs will convert a tab to 4 spaces. This is the recommended way.
- There are two conventional styles for function braces:
	- Opening curly brace on the same line as the statement.
	- Opening curly brace on its own line and same indentation with the closing curly brace (recommended).
- Each statement within curly braces should start one tab in from the closing brace of the function it belongs to.
- Lines should be limited to 80 characters or less.
- If a long line is split with an operator (e.g. `<<` or `+`), the operator should be placed at the beginning of the next line:

```C++
std::cout << 3 + 4
    + 5 + 6
    * 7 * 8;
```

- Use whitespace to align values or comments:

```C++
cost          = 57;  // align
pricePerItem  = 24;  // the comments
value         = 5;   // for
numberOfItems = 17;  // readability

// cout lives in the iostream library
std::cout << "Hello world!\n";

// these comments are easier to read
std::cout << "It is very nice to meet you!\n";

// when separated by whitespace
std::cout << "Yeah!\n";
```

- Best practice is to be consistent with whatever style that has already been established.

### Automatic formatting
- Most modern IDEs will help you format your code.
- In Visual Studio, Edit > Advanced > Format Document/Selection (ctrl+k, ctrl+d)

### Style guides
- A **style guide** is a concise, opinionated document containing programming conventions, formatting guidelines, and best practices.
- Some commonly referenced C++ style guides include:
	- [C++ Core Guidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) - maintained by Bjarne Stroustrup and Herb Sutter
	- Google
	- LLVM
	- GCC/GNU

## Intro to literals and operators
- A **literal (literal constant)** is a fixed value that has been inserted directly into the source code.
- Literals and variables both have a value and a type. Unlike a variable, the value of a literal is fixed.
- Refer to this example:

```C++
#include <iostream>

int main()
{
    std::cout << 5 << '\n'; // print the value of a literal

    int x { 5 };
    std::cout << x << '\n'; // print the value of a variable
    return 0;
}
```

- In the above example, both output statements do the same thing (prints 5). But in the case of literal, the value is printed out directly, as opposed to being fetched from the memory.
- Literals are values that are inserted directly into the source code. These values usually appear directly in the executable code (unless they are optimized out).

### Operators and operands
- In mathematics, an **operation** is a process involving zero or more input values (called **operands**) that produces a new value (called an **output value**). The specific operation to be performed is denoted by a symbol called an **operator**.
	- For example, for a statement like `int x = 1 + 2;`, 1 and 2 are operands and the + is the operator.
- Common operators:
	- addition `+`
	- subtraction `-`
	- multiplication `*`
	- division `/`
	- equality `==` / inequality `!=`
	- assignment `=`
	- insertion `<<` / extraction `>>`
- The number of operands that an operator takes as input is called the operator's **arity**.
	- Not a common word, don't use this word willy nilly
- Operators come in four different arities:
	- **Unary** : acts on one operand. For example, given `-5`, the `operator-` takes literal operand `5` and flips its sign to produce new output value `-5`.
	- **Binary** : acts on two operands placed on left and right. For example, given `1 + 2`, the `operator+` takes the left operand `1` and the right operand `2` and outputs `3`. The insertion `<<` and extraction `>>` operators are also binary operators.
	- **Ternary** : acts on three operands. There is only one, which is the conditional operator. This will be covered later.
	- **Nullary** : operators act on zero operands. There is only one, which is the throw operator. This will be covered later.
- Note that some operators have more than one meaning depending on how they are used. For example, `operator-` has two contexts: used in unary form to invert a number's sign, and used in binary form to do subtraction.

### Chaining operators
- Operators can be chained together such that the output of one operator can be used as the input for another operator.
	- For example, given `2 * 3 + 4`, the multiplication goes first (`2 * 3`) and then the result of that is fed to the plus operator (`6 + 4)`.
- The order in which operators execute is a topic that will be covered more later on. For now, it's enough to know that the arithmetic operators execute in the same order as they do in standard math: PEMDAS.
	- Parenthesis > Exponents > Multiplication/Division > Addition/Subtraction
	- "Please Excuse My Dear Aunt Sally"

### Return values and side effects
- Some operators have additional behaviors. An operator (or function) that has some observable effect beyond producing a return value is said to have a **side effect**.
	- For example, given `x = 5;`, the changed value of `x` is observable even after the operator has finished executing.
	- Another example, given `std::cout << 5;`, the number `5` gets printed to console and stays there even if the statement has finished executing.

## Intro to expressions

### Expressions
- An **expression** is a non-empty sequence of literals, variables, operators, and function calls that calculates a single value.
- The process of executing an expression is called **evaluation**.
- When an expression is evaluated, each of the terms inside the expression are evaluated, until a single value remains - referred to as the **result** of the expression.
- Expressions are always evaluated as part of statements.
	- For example, given `int x = 2+3;`, the expression `2+3` is part of a statement that assigns a value to `x`.
	- Above statement broken down into its syntax would look like this: `type identifier operator expression`.
- A statement that consists of an expression followed by a semicolon is called an **expression statement**.
- Expression statement that produces a value only to discard it, is considered useless (some compilers may produce warnings).
- Subexpression : an expression used as an operand.
	- For example, subexpressions of `x = 4 + 5` are `x` and `4 + 5`.
- Full expression : an expression made up of subexpression(s).
	- For example, `2`, `2 + 3`, and `x = 4 + 5` are all full expressions.
- Compound expression : an expression that contains two or more uses of operators.
	- For example, `x = 4 + 5` is a compound expression because it contains `operator=` and `operator+`.

## Intro to functions
- A **function** is a reusable sequence of statements designed to do a particular job.
- Functions that you write yourself are called **user-defined functions**.
- The structure of a function looks like this:

```C++
returnType functionName() // function header
{
	// function body
}
```

- Unlike some other programming languages, C++ does not allow for functions to be defined inside other functions. The following program is NOT legal:

```C++
#include <iostream>

int main()
{
    void foo() // Illegal: this function is nested inside function main()
    {
        std::cout << "foo!\n";
    }

    foo(); // function call to foo()
    return 0;
}
```

- "foo" is a meaningless word that is often used as a placeholder name for a function or variable when the name is unimportant to the demonstration of some concept.
	- Such words are called **metasyntactic variables**, though they're often called **placeholder names** instead.
	- Other common metasyntactic variables include bar, baz, and 3-letter words that end in oo, such as goo, moo, and boo.

## Function return values
### Return values
- A function can return a value or none at all.
- A function has to indicate what type of value will be returned - which is done by setting the function's **return type** which is defined before the function's name.
	- For example, if the function returns an integer value, then `int` needs to be indicated before the function name.
- If the function does not return a value, it has to indicate that it doesn't, which can be done by setting the function's return type as `void`.
	- Do not put a return statement at the end of a void function.
- It's always a good idea to leave a comment indicating what the return values mean.

### Status codes
- The return value from `main()` is sometimes called a **status code (aka exit code)**, which is passed back to the caller of the program to indicate that the program has run successfully (or not).
- If the status code is `0`, then the program ran normally.
	- A non-zero status code is often used to indicate failure.
- The C++ standard only defines the meaning of 3 status codes:
	- `0`
	- `EXIT_SUCCESS`
	- `EXIT_FAILURE`

### A value-returning function / no return value
- A function that returns a value is called a **value-returning function**.
	- Any function that is not `void` function is value-returning.
- A value-returning function MUST return a value of that type, otherwise undefined behavior will result.
- `main()` is the only exception to the rule, where it will implicitly return `0` if a return statement is not provided.

### Functions return a single value
- A value-returning function can only return a single value back to the caller each time it is called.
- Note that the value provided in a return statement doesn't need to be literal - it can be the result of any valid expression, including a variable or even a call to another function that returns a value.
- There are various ways to work around the single value limitation, which will be covered later on.

### Don't Repeat Yourself
- One of the central tenets of good programming and the main point of a function is "Don't Repeat Yourself" (DRY).
	- If it takes several lines of code to complete a task and it needs to be repeated, it's better to turn it into a function so that only one line of code is repeated.
- DRY is meant to be a guideline, not an absolute rule. DRY can harm overall comprehension when code is broken into pieces that are too small.

## Intro to function parameters/arguments
### Function parameters and arguments
- A **function parameter** is a variable used in the header of a function which is initialized with a value provided by the caller of the function.
- For example:

```C++
void printValue(int x)
{
	std::cout << x << std::endl;
}
```

- In the example above, `int x` is the function parameter for the function `printValue()`. 
- An argument is a value that is passed from the caller to the function when a function call is made.
- For example:

```C++
printValue(5);
```

- In the example above, `5` is the argument passed to `printValue()`.

### How parameters and arguments work together
- When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter (using copy initialization). This process is called **pass-by-value**.
	- Function parameters that utilize pass-by-value are called **value parameters**.
- Note that the number of arguments must generally match the number of function parameters. Otherwise, the compiler will throw an error.
- The argument passed to a function can be any valid expression, as the argument is essentially just an initializer for the parameter, and initializers can be any valid expression.

### Using return values as arguments
- A function can be called inside function header, using return values as arguments.
	- For example, `foo(bar());`.

### Unreferenced parameters
- When a parameter is not used inside the function body, compiler sends out a warning that says **unreferenced parameter**.
- In cases where a function parameter needs to exist but is not used in the function body, the name of the function parameter can be omitted (bypasses the warning).
	- A parameter without a name is called an **unnamed parameter**.
	- It's recommended to use a comment to indicate what the name would've been.
	- For example, `void doSomething(int /*count*/);`

## Intro to local scope

### Local variables
- Variables defined inside a function are called **local variables**.
- Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized at the point of definition.
	- Local variables are destroyed in the opposite order of creation.
- An object's **lifetime** is defined to be the time between its creation and destruction.
	- Note that variable creation/destruction happen during runtime, not at compile time. Therefore, lifetime is a runtime property.
- In most cases, the destroyed object becomes invalid, and any further use of the object will result in undefined behavior.
	- At some point after destruction, the memory used by the object will be freed up.

### Local scope
- An identifier's scope determines where the identifier can be seen and used within the source code.
- When an identifier can be seen and used, we say it is **in scope**.
	- When an identifier cannot be seen nor used, we say it is **out of scope**.
- Scope is a compile-time property, and trying to use an identifier outside its scope will result in a compile error.
- Local variables defined in one function are not in scope in other functions.

### Functional separation
- Variables with duplicate names but in different scopes does not conflict with each other - meaning, variable `x` defined in `foo()` is not the same as `x` defined in `bar()`.

### Temporary objects
- A temporary object (aka anonymous object) is an unnamed object that is created by the compiler to store a value temporarily.
- There are many different ways that temporary values can be created. For example:

```C++
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

int main()
{
	std::cout << getValueFromUser() << '\n';

	return 0;
}
```

- In the example above, variable `input` is destroyed at the end of the function, and the caller receives a copy of the value. This copy of the value is stored in a temporary object, which is then passed to `std::cout` to be printed.
- Temporary objects have no scope at all. They are destroyed at the end of the full expression in which they are created.

## Forward declarations and definitions
### Forward declarations
- The compiler compiles the contents of code files sequentially. When the compiler reaches a function that is not defined (before it's called), the compiler will raise an error.
- Having functions defined before it is called is a simple solution for a simple program, but in a larger complex program, it can be tedious trying to figure out which functions call which other functions (in what order).
	- In fact, it becomes a problem when there are two or more functions that call upon each other. For example, if `foo()` calls `bar()` and `bar()` calls `foo()`, there is no way to order the functions to make it work.
- A **forward declaration** allows us to tell the compiler about the existence of an identifier before actually defining the identifier.
	- When the compiler encounters a call to the function that is not yet defined but declared instead, it'll check to make sure the function is being called correctly but won't execute the function call until the function definition is found.
- A **function declaration** (function prototype) is, as it sounds, declaring a function (but without definition). Its statement consists of the function's return type, name, and parameter types, terminated with a semicolon.
	- The function body is not included in the declaration.
	- The function declaration statement must match the function that is defined later on.
	- Forward declaration is simply a function declaration that is done before definition. Think "paying it forward".
- Example of forward declaration:

```C++
#include <iostream>

int add(int x, int y); // forward declaration of add()

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

>[!important]
>Main advantage of using forward declaration is that it allows us to use a function that is defined in a different code file.

### Forgetting the function body
- One of the common mistakes that new programmers do is forgetting to define the function after the forward declaration has been made.
	- In such case, the program may compile and run fine as long as the function is not called. However, if the function is called, the linker will raise error.

### Declarations vs. definitions
- A **declaration** tells the compiler about the existence of an identifier and its associated type information.
	- Example: `int add(int x, int y);`, `int x;`
- A **definition** is a declaration that actually implements or instantiates the identifier.
	- Note that `int x;` is both a definition and a declaration.
- Declarations that aren't definitions are called **pure declarations**.
	- In common language, the term declaration is typically used to mean a pure declaration, and a definition is used to mean a definition that also serves as a declaration.

### The one definition rule (ODR)
- The one definition rule (ODR) is a well-known rule in C++ that consists of three parts:
	- Within a file, each function, variable, type or template in a given scope can only have one definition. Definitions occurring in different scopes do not violate this rule.
	- Within a program, each function or variable in a given scope can only have one definition. This rule exists because programs can have more than one file. Functions and variables not visible to the linker are excluded from this rule.
	- Types, templates, inline functions, and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical.
- Violating part 1 of the ODR will cause the compiler to issue a redefinition error.
- Violating ODR part 2 will cause the linker to issue a redefinition error.
- Violating ODR part 3 will cause undefined behavior.
- Functions that share an identifier but have different sets of parameters are considered to be distinct functions. This is called **overloading**, and such definitions do not violate the ODR. More on this topic discussed later on.

## Programs with multiple code files
- As programs get larger, it is common to split them into multiple files for organizational or reusability purposes.
- IDEs provide functionalities to manage files in a project.
- The compiler compiles each file individually. It does not know about the contents of other code files, or remember anything it has been from previously compiled code files.
- The limited visibility and short memory is intentional, for a few reasons:
	- It allows the source files of a project to be compiled in any order.
	- When we change a source file, only that source file needs to be recompiled.
	- It reduces the possibility of naming conflicts between identifiers in different files.
- In order to call a function that is defined in another file, forward declaration of the function needs to be made (in current file).

>[!warning]
>Even if you create a file in the same project folder via File Explorer (Windows), some IDEs may ignore that file. It's best to create to create a new file by using the IDE, or add the file to the project manually.

## Naming collisions and an introduction to namespaces

### Naming collisions
- When a compiler or linker can't tell apart two identical identifiers, they will produce an error - referred to as **naming collision/conflict**.
	- Note that this error will occur even if these two functions are defined in separate files.
	- This error will occur even if the function is not called.

### Namespaces
- A namespace provides another type of scope region (called **namespace scope**) that allows you to declare names inside of it for the purpose of disambiguation. Any names declared inside the namespace won't be mistaken for identical names in other scopes.
- Only declarations and definitions can appear in the scope of a namespace (not executable statements).
- Namespaces are often used to group related identifiers in a large project to help ensure they don't inadvertently collide with other identifiers.

### The global namespace
- Any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly-defined namespace called the **global namespace (global scope)**.
- `main()` is defined inside the global namespace.
- Although variables can be defined in the global namespace, this should generally be avoided.

---

There are several ways for multiple functions to share a variable without using a global variable in C++. Here are a few methods:

1. **Passing by Reference**: You can pass the variable as a reference to the functions that need to access or modify it. This allows the functions to share the same variable.
    ```cpp
    void func1(int& x) {
        x += 5;
    }

    void func2(int& x) {
        x *= 2;
    }

    int main() {
        int a = 10;
        func1(a);
        func2(a);
        std::cout << a << std::endl; // Outputs 30
        return 0;
    }
    ```

2. **Static Local Variables**: You can declare a variable as `static` inside a function. A static local variable retains its value between function calls and is shared by all calls to that function.
    ```cpp
    void func() {
        static int x = 0;
        x += 5;
        std::cout << x << std::endl;
    }

    int main() {
        func(); // Outputs 5
        func(); // Outputs 10
        return 0;
    }
    ```

3. **Class Members**: If the functions are methods of the same class, they can share a variable by making it a member of the class.
    ```cpp
    class MyClass {
    public:
        int x;

        void func1() {
            x += 5;
        }

        void func2() {
            x *= 2;
        }
    };

    int main() {
        MyClass obj;
        obj.x = 10;
        obj.func1();
        obj.func2();
        std::cout << obj.x << std::endl; // Outputs 30
        return 0;
    }
    ```

Remember, each of these methods has its own use cases and trade-offs. It's important to choose the one that best fits your needs based on the specific requirements of your program.

---

- If global variables have to be used, it's strongly encouraged to use a global constant variable.

### Explicit namespace qualifier ::
- The `::` symbol is an operator called the **scope resolution operator**.
	- The identifier to the left of the `::` symbol identifies the namespace that the name to the right is contained within (e.g. `namespace::variable`).
	- If no identifier on the left is provided, the global namespace is assumed.
- For example, `std::cout` means `cout` that is declared in namespace `std`.
- When an identifier includes a namespace prefix, the identifier is called a **qualified name**.

### Using namespace std
- There is a way to omit a namespace whenever a function/variable is used from that namespace, and that is to use a **using directive**.
- The using directive statement is structured like `using namespace namespaceIdentifier;`.
	- For example, `using namespace std;`. Once this is in place, `cout` can be called instead of `std::cout`.

>[!warning]
>Avoid using-directives at the top of your program or in header files. They violate the reason why namespaces were added in the first place.

### Curly braces and indented code
- In C++, curly braces are often used to delineate a scope region that is nested within another scope region.
	- For example, a function defined inside the global scope uses curly braces to separate the scope region of the function from the global scope.
- In certain cases, identifiers defined outside the curly braces may still be part of the scope defined by the curly braces rather than the surrounding scope.
	- Function parameters are a good example of this.

## Intro to preprocessor
- Prior to compilation, each code file (`.cpp`) goes through a **preprocessing** phase, where a program called the `preprocessor` makes various changes to the text of the code file according to the directives (instructions).
- The preprocessor does not actually modify the original code files in any way; all changes happen either temporarily in-memory or using temporary files.
- Some of the things that the preprocessor do:
	- Strips out comments
	- Ensures each code file ends in a newline
	- Processes `#include` directives (more on this later)
- When the preprocessor has finished processing a code file, the result is called a **translation unit**.
	- The translation unit is then compiled by the compiler.
- The entire process of preprocessing, compiling, and linking is called **translation**.

### Preprocessor directives
- When the preprocessor runs, it scans through the code file to find **preprocessor directives**, which tells the preprocessor to perform certain text manipulation tasks.
	- Preprocessor directive start with a `#` symbol and end with a newline (no semicolon).
- The preprocessor directives have their own syntax.
- Although the term "directive" often means preprocessor directive, it is not always the case; the `using` directive is NOT a preprocessor directive.

### Include directive
- The `#include` directive tells the preprocessor to replace the directive with the contents of the included file.
	- For example, `#include <iostream>` replaces the line with the contents of the `iostream`.
- The included contents are then preprocessed, then the rest of the file is preprocessed.
	- When the included contents are being preprocessed, the preprocessor directives in the included contents will be preprocessed too; this becomes a recursive process.

### Macro defines
- The `#define` directive can be used to create a **macro**, which is a rule that defines how input text is converted into replacement output text.
- There are two basic types of macros: object-like macros, and function-like macros.
- **Function-like macros** act like functions, and serve a similar purpose. Their use is generally considered unsafe, and almost anything they can do can be done by a normal function.
- **object-like macros** can be defined in one of two ways:
	1. `#define IDENTIFIER`
	2. `#define IDENTIFIER substitution_text`
- The identifier for a macro can use letters, numbers, and underscores. But it cannot start with a number, and should not start with an underscore.
	- By convention, macro names are typically all upper-case, separated by underscores.

### Object-like macros with substitution text
- When the preprocessor encounters this directive, any further occurrence of the identifier is replaced by `substitution_text`. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.
- Consider the following program:

```C++
#include <iostream>

#define MY_NAME "Alex"

int main()
{
    std::cout << "My name is: " << MY_NAME << '\n';

    return 0;
}
```

- The preprocessor converts the above into the following:

```C++
// The contents of iostream are inserted here

int main()
{
    std::cout << "My name is: " << "Alex" << '\n';

    return 0;
}
```

>[!warning]
>Object-like macros with substitution text were used (in C) as a way to assign names to literals. This is no longer necessary, as better methods are available in C++. Object-like macros with substitution text are now typically only seen in legacy code, and it's best to avoid using them.

### Object-like macros without substitution text
- Macros of this form work like you'd expect - any further occurrence of the identifier is removed and replaced by nothing.
- Unlike object-like macros with substitution text, macros of this form are generally acceptable to use; especially so with conditional compilation.

### Conditional compilation
- The **conditional compilation** preprocessor directives allow you to specify under what conditions something will or won't compile. There are quite a few different conditional compilation directives, but the three most used are: `#ifdef`, `#ifndef`, and `#endif`.
- The `#ifdef` preprocessor directive allows the preprocessor to check whether an identifier has been previously `#defined`. If so, the code between the `#ifdef` and matching `#endif` is compiled. If not, the code is ignored.
- Consider the following program:

```C++
#include <iostream>

#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n"; // will be excluded
#endif

    return 0;
}
```

- The code example above prints `Joe\n` because `PRINT_JOE` is defined.
- `#ifndef` is the opposite of `#ifdef`.

>[!important]
>Conditional compilation in C++ is primarily used for the following purposes:
>
>1. **Platform-Specific Code**: You can use conditional compilation to include or exclude code based on the platform (operating system, processor type, etc.) the program is being compiled on. This is useful when certain code is only applicable or optimal for specific platforms.
>
>2. **Debugging and Testing**: Conditional compilation is often used to include debugging or testing code that should not be part of the final release version of the program. For example, you might have additional logging or assertions in a debug build that are disabled in a release build.
>
>3. **Feature Flags**: You can use conditional compilation to enable or disable features in your program. This can be useful for gradually rolling out new features, or for disabling features that aren't ready yet.
>
>4. **Backward Compatibility**: If you're working with different versions of a library or a language feature, conditional compilation can help manage code that should only be compiled with certain versions.
>
>Remember, while conditional compilation is a powerful tool, it can also make code harder to read and maintain if overused. It's generally a good idea to minimize the amount of conditionally compiled code in your program.

### \#if 0
- One way to use conditional compilation is to comment out a block of code, which can be done by using `#if 0` directive.
- Note that multi-line comments cannot be nested; meaning, a code block that already contains a multi-line comment cannot be commented out using another multi-line comment.
	- `#if 0` provides a convenient way to circumvent this issue.
- Example:

```C++
#include <iostream>

int main()
{
    std::cout << "Joe\n";

#if 0 // Don't compile anything starting here
    std::cout << "Bob\n";
    /* Some
     * multi-line
     * comment here
     */
    std::cout << "Steve\n";
#endif // until this point

    return 0;
}
```

### object-like macros don't affect other preprocessor directives
- Macros only cause text substitution for non-preprocessor commands.

### The scope of \#defines
- Directives are resolved before compilation, from top to bottom on a file-by-file basis.
- Because `#include` directive replaces the `#include` directive with the content of the included file, the directives from the included file are copied into the current file. These directives will then be processed in order.
- Consider this example:

Alex.h:
```C++
#define MY_NAME "Alex"
```

main.cpp:
```C++
#include "Alex.h" // copies #define MY_NAME from Alex.h here
#include <iostream>

int main()
{
	std::cout << "My name is: " << MY_NAME << '\n';

	return 0;
}
```

- In the example above, `MY_NAME` is replaced with `"Alex"`.
- Once the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined.
	- In other words, directives defined in one file do not have any impact on other files (unless they are included into another file).

## Header files

### Headers and their purpose
- Along with C++ code files (with `.cpp` extension), there is another type of file called a **header file** with an extension `.h`, `.hpp`, or none at all.

>[!important]
>In C++, a header file (with the `.h` or `.hpp` extension) serves several important purposes:
>
>1. **Function Declarations**: Header files are commonly used to declare functions. This allows these functions to be used (called) in other source files that include the header file.
>
>2. **Type Definitions**: You can define new types (like `struct`, `class`, `enum`, `typedef`, etc.) in a header file. These types can then be used in other source files that include the header file.
>
>3. **Constant Definitions**: Constants that are used in multiple source files are often defined in a header file.
>
>4. **Template Definitions**: Unlike function and class declarations, template definitions (the actual implementation of a template function or class) have to be in the header file, because the compiler needs to have access to the entire template definition to generate code for each instantiation of the template.
>
>5. **Inline Function Definitions**: Definitions of inline functions must be in the header file. Like templates, the compiler needs to have access to the entire function definition to generate inline code.
>
>Remember, when you define something in a header file, you should use include guards (`#ifndef`, `#define`, `#endif`) or `#pragma once` to prevent multiple inclusion of the same header file, which could lead to redefinition errors.

### Using standard library header files
- Functions such as `std::cout` has been forward declared in the `iostream` header file, and defined somewhere else depending on the compiler being used.

### Forward declaration with header files
- One of the most common usage of the header files is to propagate forward declarations by including headers
- Example:

add.h
```
int add(int x, int y);
```

main.cpp
```C++
#include "add.h"
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

add.cpp
```C++
#include "add.h"

int add(int x, int y)
{
    return x + y;
}
```

- Reminder that function definitions inside header files is highly discouraged.

### Do not include source files
- `#include` directives should always be used to include header files - and never source files `.cpp`.
	- The preprocessor will allow including source files, but this invites many troubles along the way.

### Angled brackets vs. double quotes
- The way you specify the file to be included with `#include` directive can affect how the compiler searches for it.
- If you use quotation marks, the compiler first looks for the file in the same directory as the current file. If it doesn't find the file there, it then searches in the directories specified by the include path. This is typically used for including project-specific headers.
	- `#include "my_header.h"`
- If you use angled brackets, the compiler only searches in the directories specified by the include path. It does not look in the same directory as the current file. This is typically used for including headers from the standard library or other libraries installed on your system.
	- `#include <iostream>`

### Including header files from other directories
- One way to include header files from other directories is to use the relative path.
	- For example, `#include "../others/otherHeader.h"`
- Absolute path works too.
- Another way to include header files is to add the path to the header folder in the IDE's setting.
	- Visual Studio has a setting called "Include Directories"
- It's recommended to use the IDE's settings because it'd become a hassle to fix the code in every code file if there's ever a structural change to the project.

### Headers may include other headers
- It's common that a header file will need a declaration/definition that lives in a different header file. Because of this, header files will often include other header files.
- The additional header files that are included by other header files is called **transitive includes**.
- The content of the transitive includes are available for use in your code file. However, you generally should not rely on the content of headers that are included transitively. The implementation of header files may change over time, or be different across different systems.
	- This is easily avoided by explicitly including all of the header files the content of your code file requires.
- Unfortunately, there is no easy way to detect when your code file is accidentally relying on content of a header file that has been included by another header file.

### The include order of header files
- If your header files are written properly and includes everything they need, the order of inclusion shouldn't matter. What matters is if there is a missing include, it should be flagged by the compiler.
- To maximize the chance that missing includes will be flagged by compiler, order the `#include` directives as follows:
	1. The paired header files (header that pairs with a code file) from your project
	2. Other header files from your project
	3. 3rd party library headers
	4. Standard library headers

## Header guards
- A **header guard (aka include guard)** is a way to prevent a header file from being included multiple times in the same file or in other files that include it. This is important because including the same declarations multiple times can lead to redefinition errors.
- Here's how a typical header guard looks:

```C++
#ifndef MY_HEADER_H
#define MY_HEADER_H

// declarations here

#endif // MY_HEADER_H
```

- It's best practice to set the identifier as all caps, full filename, and ending with `_H` to indicate a header file is being included.
	- For example, `my_header.h` is referred to as `MY_HEADER_H`.
- Because there is a possibility that two separate header files from different directories may have a same filename (in large projects), it's recommended to use more complex/unique name in header guards. Examples:
	- `PROJECT_PATH_FILE_H`
	- `FILE_LARGE-RANDOM-NUMBER_H`
	- `FILE_CREATION-DATE_H`
- As an alternative to the `#ifndef`, `#define`, and `#endif` pattern, some compilers also support `#pragma once`, which serves the same purpose and is placed at the top of the file.
	- However, this method is not part of the C++ standard.

### Header guards do not prevent a header from being included into different code files
- As a reminder from previous lessons, the lifetime of a definition ends with the file. Meaning, a compiler will not consider a function defined in a file to be defined in another file.
- Taking the fact above into consideration, a header file that is included in multiple files will invoke a `define` directive even if the header guard is in place.
	- This means that if a function is defined in the header file and the header file is included in multiple code files, then the function will be defined multiple times - which leads to redefinition error that the linker raises.
	- The `#ifndef` directive will not stop a macro from being defined because the definition only lasts until the end of file.
- Note that main usage for the header guard is to prevent redefinition of a function within the same file.

### Custom type definition in header files
- While it's generally recommended not to define anything in header files, there are some cases where it's necessary to put the definitions in a header file.

>[!important]
>Defining custom types (like classes, structs, enums, typedefs, etc.) in header files is a common practice in C++ for several reasons:
>
>1. **Reusability**: By defining a custom type in a header file, you can `#include` that header file in any source file that needs to use the type. This promotes code reusability and helps keep your code organized.
>
>2. **Separation of Interface and Implementation**: It's a common practice in C++ to declare the interface (i.e., the class definition) in a header file and the implementation (i.e., the method definitions) in a corresponding source file. This helps to hide the implementation details and only expose the interface to the users of the class.
>
>3. **Compilation Efficiency**: When a type is defined in a header file, the compiler only needs to parse the type definition once, even if the header file is included in multiple source files. This can make the compilation process more efficient.
>
>4. **Linking**: When you define a type in a header file and include that header in multiple source files, the linker ensures that all the source files are referring to the same type. This is important for maintaining consistency and avoiding errors.
>
>Remember, when you define a type in a header file, you should use include guards or `#pragma once` to prevent multiple inclusion of the same header file, which could lead to redefinition errors.

## How to design a program
Skipped - refer to https://www.learncpp.com/cpp-tutorial/how-to-design-your-first-programs/

## Syntax and semantic errors
- A **syntax error** occurs when a statement is not valid according to the grammar of the C++ language.
	- Includes errors such as missing semicolons, using undeclared variables, mismatched parentheses, and etc.
- A **semantic error (aka logic error)** occurs when code is grammatically correct but does not produce the desired behavior or outcome. Unlike syntax errors which are easily identified and resolved by the compiler, semantic errors are not detected during the compilation process.
	- Division by 0 is an example of semantic error.
	- Using variables that are not initialized (therefore returns garbage) is an example of semantic error.
	- Having a function named `add()` only to have its result being a subtraction is an example of semantic error.
	- Statements that do not execute because it's placed after a return statement is an example of semantic error.

## Debugging tactics
- While printing out information in between steps is useful for debugging, it clutters the code and the output of the program. Additionally, it may require modification of your code which can introduce new bugs.
- There are ways to improve debug statements, such as using conditional compilation and using a logger.

### Debugging with conditional compilation
- Using conditional compilation (`#define`, `#ifdef`, and `#endif`), debugging statements can be turned on or off. For example:


```C++
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\n';

    return 0;
}
```

- In the example above, debugging statements using `std::cerr` can be toggled on/off by un/commenting out `#define ENABLE_DEBUG`.
- Downside of this approach is that it creates more code clutter, and introduces possibility of human errors where debug features only work partially or none at all.

### Using a logger
- An alternative approach to conditionalized debugging is to send the debugging information to a a log.
- A **log** is a sequential record of events that have happened, usually time-stamped.
- The process of generating a log is called **logging**.
- Typically, logs are written to a file on a disk (called a **log file**) so they can be reviewed later.
- Log files have a few advantages:
	- Debug output is separated from normal output, therefore less cluttering and more readability.
	- Log files can be easily sent to other people for diagnosis.
- There are many logger libraries:
	- [plog](https://github.com/SergiusTheBest/plog): one recommended by the guide. It is a header-only logging library.
	- **spdlog**: This is a very fast, header-only/compiled, C++ logging library. It supports various log targets like rotating log files, daily log files, console logging, and more.
	- **easyloggingpp**: This is an extremely powerful, extendable, light-weight, fast performing, thread and type safe C++ logging library. It provides the ability to write logs in your own customized format.
	- **glog**: This is Google's C++ logging module. It provides application-level logging based on C++-style streams and various helper macros.
	- **Apache Log4cxx**: This is a logging framework for C++ patterned after Apache log4j. It uses Apache Portable Runtime for most platform-specific code and should be usable on any platform supported by APR.
	- **CppLogging**: This C++ Logging Library provides functionality to log different events with a high throughput in a multithreaded environment into different sinks (console, files, rolling files, syslog, etc.).
- An example of using `plog` for logging:

```C++
#include <plog/Log.h> // Step 1: include the logger headers
#include <plog/Initializers/RollingFileInitializer.h>
#include <iostream>

int getUserInput()
{
	PLOGD << "getUserInput() called"; // PLOGD is defined by the plog library

	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
	plog::init(plog::debug, "Logfile.txt"); // Step 2: initialize the logger

	PLOGD << "main() called"; // Step 3: Output to the log as if you were writing to the console

	int x{ getUserInput() };
	std::cout << "You entered: " << x << '\n';

	return 0;
}
```

- Note that debugging can be toggled on/off by replacing `plog::debug` with `plog::none` in step 2.

## Integrated debugger
Skipping, refer to https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/

## Intro to fundamental data types
### Bits, bytes, and memory address
- To recap briefly, computers have RAM that is available for programs to use. When a variable is defined, a piece of that memory is set aside for that variable.
- The smallest unit of memory is a **binary digit (aka bit)**, which can hold a value of 0 or 1.
- Memory is organized into sequential units called **memory addresses**, where we can find and access the contents of memory at a particular location.
- In modern computer architectures, memory address is not assigned to each bit; instead, it gets assigned to each **byte** (8 sequential bits).
	- This isn't quite correct, but more on this later.

### Data types
- A **data type** is a sequence of bits that are arranged in a meaningful way.
	- For example, a sequence of bits `01000001` can be interpreted as an integer value of `65`.

### Fundamental data types
- C++ comes with built-in support for many different data types - such are called fundamental data types, basic types, primitive types, or built-in types.
- Fundamental data types include:
	- `float`
	- `double`
	- `bool`
	- `char`
	- `int`
	- `nullptr_t`
	- `void`
- Note that `string` is not a fundamental data type, instead it is considered a compound type. More on this later.
- Many of the types defined in newer versions of C++ use a `_t` suffix. This suffix means "type".

## Object sizes and the sizeof operator
- Although it's been stated before that each byte of memory gets assigned a unique address, it's not quite true - it's just an analogy to help understand memory better. The truth is that the amount of memory that an object uses is based on its data type, and most data types take up more than 1 byte of memory.

>[!important]
>Although we typically access memory through variable names and not directly via memory addresses, there are several reasons it is useful to know how much memory an object uses.
>
>1. **Memory Management**: When you're working on systems with limited memory resources, such as embedded systems or mobile devices, knowing the size of objects helps you manage memory more efficiently. This can prevent memory overflows and optimize the use of available memory.
>
>2. **Performance Optimization**: In performance-critical applications, such as game development or high-frequency trading systems, knowing the size of objects can help you optimize memory access patterns. Smaller objects can lead to better cache utilization and faster access times.
>
>3. **Data Structures**: When designing data structures, such as linked lists, trees, or hash tables, knowing the size of the objects stored in these structures can help you estimate the overall memory footprint and choose the most appropriate data structure for your needs.
>
>4. **Serialization and Networking**: When sending data over a network or saving it to a file, knowing the size of objects helps you allocate the correct amount of memory for serialization and deserialization. This ensures that data is transmitted or stored efficiently.
>
>5. **Debugging and Profiling**: When debugging memory-related issues, such as memory leaks or buffer overflows, knowing the size of objects can help you identify the source of the problem. Profiling tools often provide information about the memory usage of objects, which can be used to optimize your code.
>
>6. **Custom Allocators**: In scenarios where you implement custom memory allocators, knowing the size of objects is crucial for allocating and deallocating memory blocks correctly. This is often used in real-time systems or applications with specific memory management requirements.
>
>7. **Interfacing with Hardware**: When interfacing with hardware devices, such as graphics cards or network interfaces, knowing the size of objects can help you correctly configure memory buffers and ensure efficient data transfer between the CPU and the hardware.

- New programmers often focus too much on optimizing their code to use as little memory as possible. In most cases, this makes a negligible difference. Focus on writing maintainable code, and optimize only when and where the benefit will be substantive.

### Fundamental data type sizes
- The C++ standard does not define the exact size (in bits) for any of the fundamental types; it does define what minimum size should be under some assumptions:
	- A byte is 8 bits
	- Memory is byte addressable, so the smallest object is 1 byte
	- Floating point support is IEEE-754 compliant
	- Either 32-bit or 64-bit architecture computer is being used
- With the assumptions above, it can be said that:

![[Pasted image 20240731154252.png]]

- If a program must assume that a type has a certain size, it's possible to have the compiler fail a build if it is compiled on an architecture where this assumption is not true. More on this later.

### The sizeof operator
- C++ provides an operator named `sizeof()` that takes either a type or a variable and returns its size in bytes. For example:
	- `sizeof(bool)` should return `1` (byte).
	- `int x = 8; sizeof(x);` should return `4` (bytes).
- Note that using `sizeof()` on an incomplete type (such as `void`) will result in a compilation error.

>[!important]
>Types that use less memory is not always faster to process than types that use more memory.
>CPUs are often optimized to process data of a certain size (e.g. 32 bits), and types that match that size may be processed quicker.

## Signed integers
- An integer is an integral type that can represent positive and negative whole numbers, including 0.
- C++ has 4 primary fundamental integer types available:
	- `short` - 16 bits
	- `int` - 16 bits
	- `long` - 32 bits
	- `long long` - 32 bits
- Note that the larger integers can hold bigger range of numbers.
- Technically, the `bool` and `char` types are considered to be integral types because they store values as integer values. But for now, these will be excluded from discussion.
- The attribute of a number being positive, negative, or zero is called the number's **sign**.
- By default, integers are **signed**, meaning that the number's sign is stored as part of the number. It also means that it can hold both positive and negative numbers (and 0).
- In binary representation, a single bit is used for a **sign bit**, which stores the sign of the number. The non-sign bits are called the **magnitude bits** which determine the magnitude of the number.

### Defining signed integers
- Here is the preferred way to define the four types of signed integers:

```C++
short x;
int y;
long z;
long long w;
```

- The integer types can take an optional `signed` keyword, which by convention is typically placed before the type name:

```C++
signed short x;
signed int y;
signed long z;
signed long long w;
```

- The `signed` keyword should not be used though, as it is redundant since integers are signed by default.

### Signed integer ranges
- A variable with `n` bits can hold $2^n$ possible values.
- The set of specific values that a data type can hold is called **range**.
- The range of an integer variable is determined by two factors: its size in bits, and its sign.
- By definition, an 8-bit signed integer has a range of `-128` to `127` (inclusive).
	- An 8-bit integer can hold `256` possible values. Because `1` bit is used for sign, `7` bits are used for the magnitude - which means `128` values for each sign.
- An n-bit signed variable has a range of $[-(2^{n-1}), 2^{n-1}-1]$.

### Overflow
- When a value greater than its range is assigned to an integer, an undefined behavior called **overflow** occurs.
	- For example, assigning `140` to an 8-bit signed integer causes an overflow.

>[!important]
>An overflow occurs when a calculation produces a result that exceeds the maximum value that can be stored in a given data type. This can lead to several types of errors and unexpected behavior:
>
>1. **Wraparound**: In many systems, when an overflow occurs, the value wraps around to the minimum value of the data type. For example, if an `unsigned int` exceeds its maximum value, it wraps around to zero. This can lead to incorrect calculations and logic errors.
>
>2. **Data Corruption**: Overflow can cause data corruption, where the value stored in a variable is not what was intended. This can lead to unpredictable behavior and bugs that are difficult to trace.
>
>3. **Security Vulnerabilities**: Overflow can be exploited by attackers to cause buffer overflows, which can lead to security vulnerabilities such as arbitrary code execution or denial of service attacks.
>
>4. **Program Crashes**: In some cases, overflow can cause a program to crash or terminate unexpectedly. This can happen if the overflow leads to invalid memory access or other critical errors.
>
>5. **Loss of Precision**: Overflow can result in a loss of precision, especially in floating-point calculations. This can lead to inaccurate results and affect the reliability of numerical computations.
>
>6. **Undefined Behavior**: In some programming languages, overflow can lead to undefined behavior, where the program's behavior is unpredictable and may vary depending on the compiler or runtime environment.
>
>To prevent overflow, it's important to use appropriate data types, perform bounds checking, and use libraries or language features that provide safe arithmetic operations.

### Integer division
- When doing division with two integers (called **integer division**), C++ always produces an integer result. Since integers can't hold fractional values, any fractional portion is simply dropped (NOT rounded).
- Integer division is safe to use and desirable in certain cases.

## Unsigned integers
- **Unsigned integers** are integers that can only hold non-negative whole numbers (0 and up).
	- It does not use a sign bit, which means all bits are magnitude bits.
- To define an unsigned integer, `unsigned` keyword is placed before the type.
	- For example, `unsigned int x;`
- An n-bit unsigned variable has a range of $[0, 2^n-1]$.
	- The range of an 8-bit unsigned integer is `0` to `255`.

>[!warning] Unsigned integer overflow?
>There isn't technically an overflow for unsigned integer. When a number beyond the type's range is given, the number simply "wraps around"; that is to say, the number is divided by one greater than the largest number of the type and only the remainder is kept.
>
>For example, assigning a value of `280` for 8-bit unsigned integer results in `280 % 256 = 24`.
>
>Wrap around works with negative numbers a bit differently. The result is the sum of the number and one greater than the largest number of the type.
>
>For example, assigning a value of `-1` for 8-bit unsigned integer results in `256 + (-1) = 255`.
>
>Most compilers will give a warning when an overflow occurs, with context such as "the integer literal is out-of-range for the given type".

>[!sidenote] Nuclear Gandhi Meme
>In computer science, an example of unsigned integer overflow often includes a meme known as "Nuclear Gandhi". In a PC game Civilization, Gandhi was known for being nuke crazy despite his expected passive nature. People speculated that Gandhi's aggression setting was related to unsigned integer overflow; however, the devs denied this to be true.
>
>For fun reading, refer to https://en.wikipedia.org/wiki/Nuclear_Gandhi

- Because of the wrap-around behavior of unsigned integers, it's recommended to avoid using unsigned integers.

---

Unsigned integers are useful in several real-life scenarios where negative values are not meaningful or allowed. Here are some examples:

1. **Counting and Indexing**: When you need to count items or index arrays, negative values don't make sense. Using unsigned integers ensures that your counts and indices are always non-negative.

```cpp
std::vector<int> myVector(10);
for (unsigned int i = 0; i < myVector.size(); ++i) {
    // Do something with myVector[i]
}
```

2. **Memory Addresses**: Memory addresses are inherently non-negative. Using unsigned integers to represent memory addresses ensures that you don't accidentally use negative values.

```cpp
uintptr_t address = reinterpret_cast<uintptr_t>(ptr);
```

3. **Bit Manipulation**: When performing bitwise operations, unsigned integers are often used because they provide a clear representation of the bits without the complications of sign bits.

```cpp
unsigned int flags = 0b1010;
flags |= 0b0100; // Set a bit
```

4. **File Sizes and Offsets**: File sizes and offsets are always non-negative. Using unsigned integers to represent these values ensures that you don't accidentally use negative values.

```cpp
std::ifstream file("example.txt", std::ios::binary);
file.seekg(0, std::ios::end);
unsigned int fileSize = file.tellg();
```

5. **Network Protocols**: Many network protocols use unsigned integers to represent various fields, such as packet lengths, sequence numbers, and port numbers. Using unsigned integers ensures that these values are always non-negative.

```cpp
unsigned short port = 8080;
```

6. **Graphics and Game Development**: In graphics and game development, unsigned integers are often used to represent color values, texture coordinates, and other attributes that are inherently non-negative.

```cpp
unsigned char red = 255;
unsigned char green = 128;
unsigned char blue = 64;
```

These are just a few examples of where unsigned integers are necessary and useful. Using unsigned integers in these scenarios helps to prevent errors and ensures that your code behaves as expected.

---

## Fixed-width integers and size_t
### Fixed-width integers
- Although most data types do not have definitive memory sizes, there are some that are guaranteed to be the same size on any architecture.
- ![[Pasted image 20240801063805.png]]
- C++ officially adopted these fixed-width integers as part of C++11. They can be accessed by including the `<cstdint>` header, where they are defined inside the `std` namespace.
- An example:

```C++
#include <cstdint> // for fixed-width integers
#include <iostream>

int main()
{
    std::int16_t i{5};
    std::cout << i << '\n';
    return 0;
}
```

- The fixed-width integers have two downsides that are typically raised:
	- They are not guaranteed to be defined on all architectures, though this is highly unlikely.
	- They may be slower to process on some architectures depending on width (32-bit/64-bit), though it's hard to know without actually measuring.

### Fast and least integers
- As alternative to fixed-width integers, C++ also defines two sets of integers that are guaranteed to be defined: the fast integers, and least integers.
- The fast integers provide the fastest signed/unsigned integer type with at least a certain width.
	- For example, `std::int_fast32_t` will give the fastest signed integer type that's at least 32 bits.
	- By fastest, it means the integral type that can be processed most quickly by the CPU.
- The least integers provide the smallest signed/unsigned integer type with at least a certain width.
	- For example, `std::uint_least32_t` will give the smallest unsigned integer type that's at least 32 bits.
- The fast and least integers have their own downsides:
	- Not many programmers actually use them, and a lack of familiarity can lead to errors.
	- The fast types can lead to memory wastage, as their actual size may be larger than indicated.
	- Because the size of the fast/least integers can vary, it's possible your program may exhibit different behaviors on different architectures (think overflow and wrap around).

#### Fast integers : usage and trade-offs

>[!important] Fast integers usage
>In C++, fast integers, such as `int_fast32_t` or `uint_fast32_t`, are used when you need the fastest possible integer type that is at least a certain width (e.g., 32 bits). These types are particularly useful in performance-critical applications where the speed of integer operations is crucial. Here are some scenarios where fast integers might be necessary:
>
>1. **High-Performance Computing**: In applications like scientific computing, simulations, or real-time data processing, where every millisecond counts, using fast integers can help optimize performance.
>2. **Embedded Systems**: In resource-constrained environments, such as microcontrollers or embedded systems, fast integers can help improve the efficiency of the code.
>3. **Game Development**: When developing games, especially those with complex physics or graphics calculations, using fast integers can help achieve smoother and more responsive gameplay.
>4. **Algorithm Optimization**: In algorithms that involve a large number of integer operations, such as sorting, searching, or mathematical computations, fast integers can help reduce the overall execution time.
>
>Fast integers are typically chosen by the compiler to be the most efficient type for the target architecture, ensuring that operations on these integers are as fast as possible.

>[!important] Fast integers trade-offs
>Using fast integers in C++ comes with several trade-offs:
>
>Advantages:
>1. **Performance**: Fast integers are optimized for the target architecture, which can lead to faster execution of integer operations.
>2. **Clarity**: Using types like `int_fast32_t` clearly indicates the intent to use the fastest available integer type of at least 32 bits.
>
>Disadvantages:
>1. **Portability**: The actual size of fast integers can vary between different platforms. For example, `int_fast32_t` might be 32 bits on one platform and 64 bits on another. This can lead to inconsistencies when porting code.
>2. **Memory Usage**: Fast integers might use more memory than their fixed-width counterparts. For instance, on a 64-bit system, `int_fast32_t` could be 64 bits, which uses more memory than a 32-bit integer.
>3. **Predictability**: The size and behavior of fast integers are determined by the compiler and the target architecture, which can make it harder to predict their performance characteristics.
>
>In summary, while fast integers can provide performance benefits, they may introduce challenges related to portability, memory usage, and predictability. It's essential to consider these trade-offs based on the specific requirements of your application.

#### Least integers : usage and trade-offs

>[!important] Least integers usage
>In C++, least integers, such as `int_least32_t` or `uint_least32_t`, are used when you need the smallest integer type that is at least a certain width (e.g., 32 bits). These types are particularly useful in scenarios where memory efficiency is more critical than speed. Here are some common use cases:
>
>1. **Memory-Constrained Environments**: In systems with limited memory, such as embedded systems or IoT devices, using the smallest possible integer type helps conserve memory.
>2. **Data Storage**: When storing large amounts of data, such as in databases or file formats, using the smallest integer type can reduce the overall storage requirements.
>3. **Network Communication**: In network protocols, where data needs to be transmitted efficiently, using the smallest integer type can help minimize the amount of data sent over the network.
>
>For example, if you need to store a large array of integers and memory usage is a concern, using `int_least32_t` ensures that each integer uses the minimum amount of memory while still being at least 32 bits wide.

>[!important] Least integers trade-offs
>Using least integers in C++ comes with its own set of trade-offs:
>
>Advantages:
>1. **Memory Efficiency**: Least integers, such as `int_least32_t`, ensure that you are using the smallest possible integer type that meets the required width. This can help conserve memory, especially in memory-constrained environments.
>2. **Portability**: Least integers provide a consistent minimum width across different platforms, which can help ensure that your code behaves consistently when ported to different systems.
>
>Disadvantages:
>1. **Performance**: Since least integers prioritize memory efficiency over speed, they might not be the fastest integer type available on a given platform. This can lead to slower execution times compared to using fast integers.
>2. **Predictability**: The actual size of least integers can vary between platforms. For example, `int_least32_t` might be 32 bits on one platform and 64 bits on another. This variability can make it harder to predict the performance characteristics of your code.
>3. **Complexity**: Using least integers can add complexity to your code, as you need to be aware of the potential differences in integer sizes across platforms and handle them appropriately.
>
>In summary, while least integers can help optimize memory usage and ensure portability, they may introduce challenges related to performance, predictability, and complexity. It's essential to weigh these trade-offs based on the specific requirements of your application.

### 8-bit fixed-width integers behave like chars
- Due to an oversight in the C++ specification, most compilers define and treat `std::int8_t` and `std::uint8_t` (and the corresponding fast and least fixed-width types) identically to types `signed char` and `unsigned char` respectively.
	- This means that 8-bit fixed-width integers may behave differently than the rest of the fixed-width types, which can lead to errors.
	- This behavior is system-dependent, so a program that behaves correctly on one architecture may not compile or behave correctly on another architecture.
- When storing integral values where a specific size is important, it's generally best to avoid these 8-bit fixed-width integers (use 16-bit instead).

>[!important]
>The behavior of 8-bit fixed-width integers (`int8_t` and `uint8_t`) being treated like `char` types in C++ is due to an oversight in the C++ specification. Most compilers define and treat `std::int8_t` and `std::uint8_t` (and their corresponding fast and least fixed-width types) identically to `signed char` and `unsigned char`, respectively³.
>
>Reasons for This Behavior:
>1. **Historical Context**: The C and C++ standards have historically treated `char` as a distinct type that can be used for both character data and small integers. This dual-purpose nature of `char` has carried over to fixed-width integer types.
>2. **Compiler Implementation**: Compilers often implement `int8_t` and `uint8_t` as aliases for `signed char` and `unsigned char` to maintain compatibility with existing code and to simplify the implementation³.
>
>Why It Hasn't Been Fixed:
>1. **Backward Compatibility**: Changing the behavior of 8-bit fixed-width integers would break a significant amount of existing code that relies on the current behavior. Maintaining backward compatibility is a crucial consideration in the evolution of programming languages.
>2. **Limited Impact**: The impact of this behavior is relatively limited to specific use cases involving 8-bit integers. In most scenarios, the behavior does not cause significant issues, so there has been less urgency to address it.
>3. **Standardization Process**: Any changes to the C++ standard go through a rigorous standardization process, which involves extensive discussion and consensus-building among the community. Given the limited impact and the need for backward compatibility, this issue has not been prioritized for change.

### Best practices for integral types
- It's better to be correct than fast, and better to fail at compile time than runtime.
	- If an integral type with a fixed size is needed, use the fixed-width type; avoid fast/least types.
- <mark class="hltr-green">Prefer</mark> `int` when the size of the integer doesn't matter.
- <mark class="hltr-green">Prefer</mark> `std::int#_t` when storing a quantity that needs a guaranteed range.
- <mark class="hltr-green">Prefer</mark> `std::uint#_t` when doing bit manipulation or where well-defined wrap-around behavior is required.
- <mark class="hltr-red">Avoid</mark> `short` and `long` integers; use a fixed-width integers instead.
- <mark class="hltr-red">Avoid</mark> unsigned types for holding quantities.
- <mark class="hltr-red">Avoid</mark> 8-bit fixed-width integers
- <mark class="hltr-red">Avoid</mark> the fast/least fixed-width types
- <mark class="hltr-red">Avoid</mark> compiler-specific fixed-width integers

### what is std::size_t?
- The `sizeof()` returns the size (in bytes) of a given variable/type; the type of the value that it returns is `std::size_t`, which is an alias for an implementation-defined unsigned integral type.
	- In other words, the compiler decides if `std::size_t` is an unsigned int, an unsigned long, an unsigned long long, etc.
- `std::size_t` is used to represent the byte-size or length of objects.
- `std::size_t` is defined in a number of different headers; the best header to include is `<cstddef>`, as it contains the least number of other defined identifiers.
- Using a `sizeof()` does not require a header, even though it returns a value whose type is `std::size_t`.
- `std::size_t` is guaranteed to be unsigned and at least 16 bits, but on most systems will be equivalent to the address-width of the application.
	- For example, for 32-bit application, it will be 32-bit unsigned integer.

>[!note] `std::size_t` and upper limit on the size of an object
>Because `std::size_t` has a maximum value that it can return, it means that `sizeof()` cannot be used on an object that is larger than the maximum value (in bytes). Compilers will use this value (sometimes a half of it) as the upper limit on the size of an object that can be created.
>
>On 32/64 bit applications, this is hardly an issue. However, on 8/16 bit applications, this imposes a significant constraint on the size of objects.


## Floating point numbers
### Floating point data types
- A floating point type is a data type that can hold a number with a fractional component.
- There are three standard floating point types:
	- A single-precision `float`, typical width of 4 bytes
	- A double-precision `double`, typical width of 8 bytes
	- An extended-precision `long double`, typical width of 8, 12, or 16 bytes
- The **precision** of a floating point type defines how many significant digits it can represent without information loss.
	- `float` has 6 to 9 digits of precision. This means number with 6 significant digits are represented exactly, but beyond that is questionable.
	- `double` has 15 and 18 digits of precision.
	- `long double` has 15, 18, or 33 digits of precision.
- On modern architectures, floating point representation for `float` and `double` almost always follows IEEE 754 binary format; meaning, a `float` is 4 bytes and a `double` is 8 bytes.
- It's recommended to avoid `long double`.

>[!warning]
>From this point on, the guide will continue with the assumption that the compiler is using IEEE 754 format for `float` and `double`.

- Note that suffix `f` is attached to the value that is assigned to a `float` variable. For example, `float x = 1.0f;`.
	- The `f` suffix is not attached to the value that is assigned to a `double` variable.
	- The `f` suffix distinction is important because implicit conversion can occur - which is unnecessary.

### Floating point range
- Assuming IEEE 754 representation for 4, 8, and 16 byte representations:
	- 4 bytes :: $±1.18 \times 10^{-38}$ to $±3.4 x 10^{38}$ and $0.0$ :: with precision 6-9 significant digits (typically 7)
	- Skipping the rest.. this should just be looked up whenever it's necessary.

### Printing floating point numbers
- Consider the following example:

```C++
#include <iostream>

int main()
{
	std::cout << 5.0 << '\n';
	std::cout << 6.7f << '\n';
	std::cout << 9876543.21 << '\n';

	return 0;
}
```

- The results of the above example:

```
5
6.7
9.876543e+06
```

- Note that `std::cout` does not print the fractional part that is `0`.
- Note that `std::cout` prints numbers in scientific notation.
	- Scientific notation being representing values as $x * 10^n$, where `e+n`.
- `std::cout` has a default precision of 6, which matches with the minimum precision of a `float`. Significant digits beyond this limit will be truncated.
- Consider the following example:

code
```C++
#include <iostream>

int main()
{
    std::cout << 9.87654321f << '\n';
    std::cout << 987.654321f << '\n';
    std::cout << 987654.321f << '\n';
    std::cout << 9876543.21f << '\n';
    std::cout << 0.0000987654321f << '\n';

    return 0;
}
```

result
```C++
9.87654
987.654
987654
9.87654e+006
9.87654e-005
```

- In the above example, it can be seen that all the numbers are printed up to only 6 significant digits, and the rest are truncated (excluding the scientific notation).
- The default precision of `std::cout` can be overridden by using an output manipulator function called `std::setprecision()`, which is defined in the `<iomanip>` header. For example:

code
```C++
#include <iomanip> // for output manipulator std::setprecision()
#include <iostream>

int main()
{
    std::cout << std::setprecision(17); // show 17 digits of precision
    std::cout << 3.33333333333333333333333333333333333333f <<'\n';
    std::cout << 3.33333333333333333333333333333333333333 << '\n';

    return 0;
}
```

result
```C++
3.3333332538604736
3.3333333333333335
```

- In the example above, note that the precision of the result is limited/differs by the data types, `float` and `double`.

>[!important]
>Output manipulators (and input manipulators) are sticky; meaning that they will remain set after being set once.
>
>The one exception is `std::setw`, which sets the width of the printed text. Some IO operations reset this width, so `std::setw` should be used every time it is needed.

- Note that the precision don't just impact fractional numbers, they also impact whole numbers.

### Rounding errors & comparisons
- When precision is lost because a number can't be stored precisely, it is called a **rounding error**.
- Comparing floating point numbers can get tricky because rounding errors often give unexpected result.
- Take below example:

code
```C++
#include <iomanip> // for std::setprecision()
#include <iostream>

int main()
{
    double d{0.1};
    std::cout << d << '\n'; // use default cout precision of 6
    std::cout << std::setprecision(17);
    std::cout << d << '\n';

    return 0;
}
```

result
```C++
0.1
0.10000000000000001
```

- In the above example, note that the variable `d` outputs slightly different values - which is caused by rounding error.
	- In this case, `double` has precision up to 16 significant digits. When `std::cout` outputs the value with default precision of 6, it simply truncates the value and outputs `0.1`. However, when the precision for `std::cout` is set to 17, it went beyond the precision for `double` - which caused the rounding error, outputting `0.10000000000000001`.
- There are cases when the rounding error is even more imperceptible:

code
```C++
#include <iomanip> // for std::setprecision()
#include <iostream>

int main()
{
    std::cout << std::setprecision(17);

    double d1{ 1.0 };
    std::cout << d1 << '\n';

    double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };
    std::cout << d2 << '\n';

    return 0;
}
```

result
```C++
1
0.99999999999999989
```

- In the above example, variable `d2` should add up to `1.0` but it does not.
	- It's important to note that mathematical operations (such as addition and multiplication) tend to make rounding errors grow.
- It's always best to be wary of using floating point numbers for financial or currency data.

---

Handling floating-point rounding errors in C++ can be challenging due to the inherent limitations of representing decimal numbers in binary format. Here are some best practices to minimize and manage these errors:

Use Higher Precision Types
- **Double Precision**: Use `double` instead of `float` for higher precision. `double` provides more significant digits and a larger range.
- **Long Double**: For even higher precision, consider using `long double`.

Use Arbitrary-Precision Libraries
- **GMP (GNU Multiple Precision Arithmetic Library)**: This library provides arbitrary-precision arithmetic, allowing you to perform calculations with very high precision¹.
- **Boost.Multiprecision**: Part of the Boost C++ Libraries, it offers support for high-precision arithmetic¹.

Avoid Subtracting Nearly Equal Numbers
- **Catastrophic Cancellation**: Subtracting two nearly equal numbers can lead to significant loss of precision. Try to reformulate the problem to avoid such operations.

Use Kahan Summation Algorithm
- **Kahan Summation**: This algorithm helps reduce the error when summing a sequence of floating-point numbers by keeping a running compensation for lost low-order bits².

Normalize Values
- **Scaling**: Normalize values to a similar range before performing arithmetic operations. This can help reduce rounding errors.

Use Decimal Fixed-Point Arithmetic
- **Fixed-Point Representation**: For applications requiring precise decimal representation, consider using fixed-point arithmetic, where numbers are represented as integers scaled by a fixed factor².

Properly Format Output
- **Set Precision**: Use `std::setprecision` and `std::fixed` to control the number of significant digits when outputting floating-point numbers².
  ```cpp
  #include <iostream>
  #include <iomanip>

  int main() {
      double value = 0.1;
      std::cout << std::fixed << std::setprecision(17) << value << std::endl;
      return 0;
  }
  ```

Understand Floating-Point Arithmetic
- **Educational Resources**: Read "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David Goldberg to gain a deeper understanding of floating-point behavior².

By following these practices, you can minimize the impact of floating-point rounding errors in your C++ programs. If you have any specific scenarios or further questions, feel free to ask!

¹: [Stack Overflow](https://stackoverflow.com/questions/3420009/avoid-rounding-error-floating-specifically-c)
²: [Learn Microsoft](https://learn.microsoft.com/en-us/cpp/build/why-floating-point-numbers-may-lose-precision?view=msvc-170)

Source: Conversation with Copilot, 2024. 8. 2.
(1) avoid rounding error (floating specifically) c++ - Stack Overflow. https://stackoverflow.com/questions/3420009/avoid-rounding-error-floating-specifically-c.
(2) c++ - What is a simple example of floating point/rounding error .... https://stackoverflow.com/questions/249467/what-is-a-simple-example-of-floating-point-rounding-error?noredirect=1.
(3) c++ - Float point numbers and incorrect result due to rounding behavior .... https://stackoverflow.com/questions/40372148/float-point-numbers-and-incorrect-result-due-to-rounding-behavior.
(4) Why Floating-Point Numbers May Lose Precision. https://learn.microsoft.com/en-us/cpp/build/why-floating-point-numbers-may-lose-precision?view=msvc-170.
(5) floating point - Analyzing Numerical Error in C++ Function .... https://scicomp.stackexchange.com/questions/1007/analyzing-numerical-error-in-c-function.
(6) undefined. http://www.learncpp.com/cpp-tutorial/25-floating-point-numbers/.

---

### NaN and Inf
- There are two special categories of floating point numbers:
	- `Inf` : represents infinity, which can be positive or negative.
	- `NaN` : represents a value that is "Not a Number".
- `NaN` and `Inf` are only available if the compiler uses a specific format (IEEE 754) for floating point numbers.
- Consider the following example:

code
```C++
#include <iostream>

int main()
{
    double zero {0.0};
    double posinf { 5.0 / zero }; // positive infinity
    std::cout << posinf << '\n';

    double neginf { -5.0 / zero }; // negative infinity
    std::cout << neginf << '\n';

    double nan { zero / zero }; // not a number (mathematically invalid)
    std::cout << nan << '\n';

    return 0;
}
```

result
```console
1.#INF
-1.#INF
1.#IND
```

- Note that the results of printing `Inf` and `NaN` are platform specific, so results may vary.
	- Like in the example above, `IND` (for indeterminate) was printed for `NaN`.
- It's best practice to avoid division by zero.

## Boolean values
- Boolean values are values that are either `ture` or `false`, represented by a type called `bool`.
- The logical NOT operator `!` reverses the boolean value.
	- For example, `!false` is `true`.
- Boolean values are not actually stored as the words "true" or "false". Instead, they are stored as integral values; `1` for `true`, and `0` for `false`.
	- Boolean values are evaluated as such; `std::cout << true;` will print `1`.
- In order to print the boolean words `true` or `false`, `std::boolalpha` must be called (once).
	- e.g. `std::cout << std::boolalpha;`
	- Use `std::noboolalpha` to turn it back off.
- `bool` can be initialized using `true`/`false` or `1`/`0`.
	- e.g. `bool machineOn = 1;`
	- Uniform initialization with integral values other than 0 or 1 causes an error.
	- Copy initialization with integral values other than 0 or 1 does NOT cause an error, and is converted to `true`.
- When using `std::cin` to get user input for a boolean value, note that it only accepts `0` or `1` instead of full words like `true` or `false`.
- Boolean values are often used to as the return values for functions that check whether something is true or not.
	- Such functions are typically named starting with the word `is` (e.g. `isEqual`), or `has` (e.g. `hasCommonDivisor`).
- Comparison operators such as `==`, `!=`, `>`, `<`, and etc. will return a `bool` value.

## Intro to if statements
- A **condition** (also called a conditional expression) is an expression that evaluates to a Boolean value.
	- e.g. `true`, `1 == 1`, `1 != 0`, `(1+1) == 2`
- An **if statement** is a conditional statement that executes a code if some condition is true.
	- e.g. `if (condition==true) executeCodeA();`
- If statement can also execute when some condition is false, by using `else`.
	- e.g. `else executeCodeB();`
- If statement can be chained so that several conditions are checked one by one, by using `else if`.
	- e.g. `else if (condition==true) executeCodeC();`
- Integral values `0` and `1` can be used for conditional expression; they'll be implicitly converted to boolean values.
	- Values higher than `1` can be used too, but it will cause a warning.
- A return statement that is not the last statement in a function is called an **early return**.
	- Such a statement will cause the function to return to the caller wen the return statement is executed.
- If statements and early returns pair up well together.

>[!warning] Conditional statements have their own scope
>When a variable is declared within a conditional statement (such as if/else block), that variable is only accessible within the scope of that block.
>
>While a variable declared outside the conditional statement can be initialized inside the conditional statement, it cannot be initialized with a reference to the variable that's defined within the conditional statement.



## Chars
- The `char` data type is designed to hold a single character.
	- A **character** can be a single letter, number, symbol, or whitespace.
- The `char` type is an integral type, meaning the underlying value is stored as an integer.
- The integer stored by a `char` type is interpreted as an ASCII character, which defines a particular way to represent English characters (plus a few other symbols) as numbers between 0 and 127 (called ASCII code).
	- ASCII stands for American Standard Code for Information Interchange
	- For example, ASCII code 97 is interpreted as the character 'a'
- Character literals are always placed between single quotes.
- ASCII codes 0~31 and 127 are called the unprintable chars - due to the fact that they are now obsolete.
- `char` can be initialized by using character literals.
	- e.g. `char letterA = 'a';`
- `char` can also be initialized by using integers as well, but it should be avoided if possible.
- `char` is defined by C++ to always be 1 byte in size.
	- By default, a char may be signed or unsigned (though it's usually unsigned).
- **Escape sequences** are special characters that always starts with backlash `\`.
	- ![[Pasted image 20240802123930.png]]

- Reminder: [[#8-bit fixed-width integers behave like chars]]

### Single vs double quotes
- Single chars are always put in single quotes (e.g. `'a'`, `'+'`, `'5'`).
	- A `char` can only represent one symbol.
- Text between double quotes (e.g. `"hello world!"`) is treated as a string of multiple characters.
	- More on strings later.

### Avoid multicharacter literals
- For backwards compatibility reasons, many C++ compilers support **multicharacter literals**, which are char literals that contain multiple characters (e.g. `'56'`). If supported, these have an implementation-defined value (meaning it varies depending on the compiler).
	- Multicharacter literals should be avoided because they are NOT part of the C++ standard, and their value is NOT strictly defined.
- Multicharacter literal support sometimes causes confusion for novice programmers. Consider the following example:

```C++
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

int main()
{
	std::cout << add(1, 2) << '/n';

	return 0;
}
```

- In the above example, `3` followed by a newline is expected to print but instead, `312142` might be printed. This is because the newline character was mistyped with forward slash instead of backward slash, and `/n` multicharacter literals has implementation-defined value of `12142`.

### Other char types
- There are other variations of `char`:
	- `wchar_t`
	- `char8_t`, `char16_t`, `char32_t`
- `wchar_t` should be avoided in almost all cases (except when interfacing with the Windows API).
	- Its size is implementation defined, and is not reliable.
	- It has largely been deprecated.

#### Unicode support
- The most well-known mapping outside of ASCII is the **Unicode standard**, which maps over 144,000 integers to characters in many different languages.
	- Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called **UTF-32**).
	- Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called **UTF-16** and **UTF-8** respectively).
- `char8_t`, `char16_t`, and `char32_t` are data types that support Unicode characters.
- `char16_t` and `char32_t` were added to C++11 to provide explicit support for 16-bit and 32-bit Unicode characters.
	- These char types have the same size as `std::uint_least16_t` and `std::uint_least32_t` respectively (but are distinct types).
- `char8_t` were added in C++20 to provide support for 8-bit Unicode.
	- It is a distinct type that uses the same representation as `unsigned char`.

>[!important]
>The differences between UTF-8, UTF-16, and UTF-32 primarily lie in how they encode Unicode characters and their efficiency in terms of space and processing:
>
>UTF-8
>- **Encoding**: Uses 8, 16, 24, or 32 bits (1 to 4 bytes) to encode a character.
>- **Advantages**: 
>    - Efficient for texts with a lot of ASCII characters, as it uses only 1 byte for these characters.
>    - No issues with endianness (byte order).
>    - Widely used in web and network protocols.
>- **Disadvantages**: 
>    - Can be less efficient for texts with many non-ASCII characters, as it may require up to 4 bytes per character.
>
>UTF-16
>- **Encoding**: Uses 16 or 32 bits (2 or 4 bytes) to encode a character.
>- **Advantages**: 
>    - More efficient than UTF-8 for texts with many non-ASCII characters, as it uses 2 bytes for most characters.
>    - Commonly used in environments like Windows and JavaScript.
>- **Disadvantages**: 
>    - Can be less efficient for texts with many ASCII characters, as it uses at least 2 bytes per character.
>    - Endianness can be an issue, requiring byte order marks (BOM) to indicate the byte order.
>
>UTF-32
>- **Encoding**: Uses 32 bits (4 bytes) to encode a character.
>- **Advantages**: 
>    - Fixed-width encoding, making it simple to calculate the number of characters.
>    - No need for decoding to access individual characters.
>- **Disadvantages**: 
>    - Very space-inefficient, as it uses 4 bytes for every character, regardless of its actual size.
>    - Rarely used due to its high memory consumption.
>
>Summary
>- **UTF-8** is best for texts with many ASCII characters and is widely used in web and network protocols.
>- **UTF-16** is more efficient for texts with many non-ASCII characters and is used in environments like Windows and JavaScript.
>- **UTF-32** is simple but space-inefficient, making it less commonly used.

## Intro to type conversion and static_cast
### Implicit type conversion
- The process of converting a value from one type to another type is called **type conversion**.
- When the compiler does type conversion on our behalf without us explicitly asking, we call this **implicit type conversion**.

>[!important]
>Implicit type conversion, also known as automatic type conversion or coercion, is performed automatically by the compiler when one data type is required, but a different data type is supplied. This process allows for seamless integration of different data types in expressions and function calls without requiring explicit casts from the programmer.
>
>Common Occurrences of Implicit Type Conversion:
>
>1. **Arithmetic Operations**:
>    - When performing arithmetic operations between different data types, the compiler automatically converts the operands to a common type. For example, when adding an `int` and a `double`, the `int` is converted to a `double` before the addition.
>   ```cpp
>   int a = 5;
>   double b = 3.2;
>   double result = a + b; // 'a' is implicitly converted to double
>   ```
>
>2. **Function Calls**:
>    - When passing arguments to a function, if the argument types do not match the parameter types, the compiler performs implicit conversions to match the parameter types.
>   ```cpp
>   void printDouble(double value) {
>       std::cout << value << std::endl;
>   }
>   int x = 10;
>   printDouble(x); // 'x' is implicitly converted to double
>   ```
>
>3. **Assignment Operations**:
>    - When assigning a value of one type to a variable of another type, the compiler performs implicit conversion to match the variable's type.
>   ```cpp
>   double y = 7; // '7' is implicitly converted to double
>   ```
>
>4. **Boolean Contexts**:
>    - When using non-boolean values in boolean contexts (e.g., conditions in `if` statements), the compiler implicitly converts the values to `bool`.
>   ```cpp
>   int z = 0;
>   if (z) { // 'z' is implicitly converted to bool
>       std::cout << "This won't print." << std::endl;
>   }
>   ```
>
>Summary
>Implicit type conversions help simplify code by allowing different data types to interact seamlessly. However, it's essential to be aware of potential pitfalls, such as loss of precision or unintended behavior, especially when dealing with mixed data types.

### Type conversion produces a new value
- Important thing to note is that the type conversion does not change the type of the variable, but rather the type of the input value gets converted to match the type of the variable.
	- For example, if `float` value of `5.0f` is being assigned to `int x`, the value change from `5.0f` to `5` and then gets assigned to `x`.

### Implicit type conversion warnings
- Whenever implicit conversions occur, the compiler will generate some kind of a warning.
- Warnings can be dealt with by either suppressing it, or explicitly converting the values.

### Explicit type conversion - static_cast
- Explicit type conversion is, quite literally, a type conversion that is done explicitly, by using an operator that converts the value.
- There are several different operators for converting a value; the most common one is `static_cast`.
- `static_cast` is a casting operator that is used to perform explicit type conversions at compile time.
	- It is primarily used for safe and well-defined conversions, such as converting between related types, performing implicit conversions explicitly, and calling explicit conversion functions.
- The syntax for `static_cast` looks like this: `static_cast<new_type>(expression)`.
	- `static_cast` takes the value from an expression as input, and returns that value converted into the type specified by `new_type` (e.g. `int`, `bool`, `char`, etc.).
	- Example: `int x = static_cast<int>(5.5);`
- When explicit type conversion is used, the compiler will not generate any warning.

---

In C++, casting is the process of converting a value from one data type to another. There are several types of casts in C++, each serving different purposes and providing varying levels of safety and flexibility. Here are the main types of casts:

1. **C-Style Cast**
    - **Syntax**: `(new_type)expression` or `new_type(expression)`
    - **Usage**: This is the most basic form of casting and can perform any type of cast (static, dynamic, const, or reinterpret). However, it is not recommended because it lacks the safety and clarity of the C++-style casts⁷.

2. **`static_cast`**
    - **Syntax**: `static_cast<new_type>(expression)`
    - **Usage**: Used for compile-time type conversions that are considered safe. It can be used to convert between related types, such as numeric types or pointers within the same inheritance hierarchy¹.
    - **Example**:

```cpp
int num = 10;
double numDouble = static_cast<double>(num); // Converts int to double
```

3. **`dynamic_cast`**
    - **Syntax**: `dynamic_cast<new_type>(expression)`
    - **Usage**: Used for safe downcasting in inheritance hierarchies. It performs a runtime check to ensure the validity of the conversion. If the conversion is not possible, it returns a null pointer (for pointers) or throws a `bad_cast` exception (for references)¹⁴.
    - **Example**:
	
```cpp
Animal* animalPtr = new Dog();
Dog* dogPtr = dynamic_cast<Dog*>(animalPtr); // Downcasting
if (dogPtr) {
    dogPtr->speak();
}
```

4. **`const_cast`**
    - **Syntax**: `const_cast<new_type>(expression)`
    - **Usage**: Used to add or remove the `const` qualifier from a variable. It is primarily used to cast away constness, allowing modification of a variable that was originally declared as `const`⁸.
    - **Example**:
	
```cpp
const int* ptr = &num;
int* modifiablePtr = const_cast<int*>(ptr); // Removes constness
```

5. **`reinterpret_cast`**
    - **Syntax**: `reinterpret_cast<new_type>(expression)`
    - **Usage**: Used for low-level reinterpreting of bit patterns. It can cast any pointer type to any other pointer type, even if the types are unrelated. This cast is the most dangerous and should be used with caution⁸.
    - **Example**:
	
```cpp
int num = 10;
void* ptr = &num;
int* intPtr = reinterpret_cast<int*>(ptr); // Reinterprets void* as int*
```

Summary
- **C-Style Cast**: Basic and flexible, but not recommended due to lack of safety.
- **`static_cast`**: Safe compile-time conversions.
- **`dynamic_cast`**: Safe runtime downcasting.
- **`const_cast`**: Adds or removes `const` qualifier.
- **`reinterpret_cast`**: Low-level bit pattern reinterpreting.

Each cast serves a specific purpose and should be used appropriately to ensure code safety and clarity.

¹: [GeeksforGeeks](1)
⁴: [LearnCpp](4)
⁷: [LearnCpp](7)
⁸: [GeeksforGeeks](8)

Source: Conversation with Copilot, 2024. 8. 4.
(1) 10.6 — Explicit type conversion (casting) and static_cast. https://www.learncpp.com/cpp-tutorial/explicit-type-conversion-casting-and-static-cast/.
(2) Casting Operators in C++     - GeeksforGeeks. https://www.geeksforgeeks.org/casting-operators-in-cpp/.
(3) 25.10 — Dynamic casting – Learn C++     - LearnCpp.com. https://www.learncpp.com/cpp-tutorial/dynamic-casting/.
(4) const_cast in C++ | Type Casting operators     - GeeksforGeeks. https://www.geeksforgeeks.org/const_cast-in-c-type-casting-operators/.
(5) Type conversions     - C++ Users. https://cplusplus.com/doc/tutorial/typecasting/.
(6) C/C++ What does casting do in the low level?     - Stack Overflow. https://stackoverflow.com/questions/64573971/c-c-what-does-casting-do-in-the-low-level.
(7) Dynamic _Cast in C++     - GeeksforGeeks. https://www.geeksforgeeks.org/dynamic-_cast-in-cpp/.
(8) c++     - Regular cast vs. static_cast vs. dynamic_cast     - Stack Overflow. https://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast.
(9) static_cast in C++     - GeeksforGeeks. https://www.geeksforgeeks.org/static_cast-in-cpp/.

---

### Unsigned to signed number
- `static_cast` can be used to convert an unsigned number to a signed number.
- Example:

```C++
#include <iostream>

int main()
{
    unsigned int u { 5 };
    int s { static_cast<int>(u) }; // return value of variable u as an int

    std::cout << s << '\n';
    return 0;
}
```

>[!warning]
>The `static_cast` does not do any range checking, so if you cast a value to a type whose range doesn't contain that value, undefined behavior will result.

### 8-bit int (char) demonstration
- As previously mentioned before at [[#8-bit fixed-width integers behave like chars]], most compilers treat fixed-width 8-bit integer types such as `std::int8_t` and `std::uint8_t` (and corresponding fast/least types) identically to types `signed char` and `unsigned char`.
- Consider this example:

```C++
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t myInt{65};      // initialize myInt with value 65
    std::cout << myInt << '\n'; // you're probably expecting this to print 65

    return 0;
}
```

- In the above example, most compilers will print the result as `A` instead of `65`.
- `static_cast` can be used on these 8-bit integers to convert them to `int` type.
- It's best to avoid using 8-bit integers as input for `std::cin` because it may behave like it's getting `char` value from the user.

## Constant variables (named constants)
### Intro to constants
- A **constant** is a value that may not be changed during the program's execution.
- C++ supports two different kinds of constants.
	- **Named constants (symbolic constants)** : constant values that are associated with an identifier.
	- **Literal constants** : constant values that are not associated with an identifier.

### Types of named constants
- There are three ways to define a named constant.
	- Constant variables
	- [[#Object-like macros with substitution text]]
	- Enumerated constants (covered later)

### Constant variables
- A **constant variable** is a variable whose value cannot be changed during the program's execution.
- Constant variables are useful for reflecting things in the real world that does not change; such as the Earth's gravity, PI, speed of light, and etc.
- To declare a constant variable, simply place `const` keyword (called a **const qualifier**) adjacent to the object's type.
	- e.g. `const double gravity = 9.8;`, `float const PI = 3.14f;`
	- It's common to put const qualifier before the type.
- Constant variables must be initialized when it's defined, and then the value cannot be changed via assignment - going against any of these will result in error.
	- e.g. `const double gravity;` will result in error.
	- e.g. `float const PI = 3.14f; PI = 3.141f;` will result in error.
- There are a number of different naming conventions for const variables.
	- All caps with snake_case (e.g. `EARTH_GRAVITY`)
	- `k` prefix camelCase (e.g. `kEarthGravity`)
	- Same as normal variables (e.g. `earthGravity`)

>[!important]
>A **type qualifier** (qualifier for short) is a keyword that is applied to a type that modifies how that type behaves. The `const` used to declare a constant variable is called a const type qualifier (or const qualifier). There is also another qualifier named `volatile`.

### Const function parameters
- Function parameters can be made constants via the `const` keyword. For example:

```C++
#include <iostream>

void printInt(const int x)
{
    std::cout << x << '\n';
}

int main()
{
    printInt(5); // 5 will be used as the initializer for x
    printInt(6); // 6 will be used as the initializer for x

    return 0;
}
```

---

Using `const` function parameters in C++ is necessary and beneficial in several scenarios:

1. **Preventing Modification**
	- **Read-Only Parameters**: When you want to ensure that a parameter passed to a function is not modified within the function, you can declare it as `const`. This helps prevent accidental changes and makes the code safer³.

```cpp
void printValue(const int value) {
	std::cout << value << std::endl;
	// value = 10; // Error: value is read-only
}
```

2. **Self-Documentation**
	- **Code Clarity**: Using `const` makes it clear to anyone reading the code that the parameter is not intended to be modified. This improves code readability and maintainability¹.

```cpp
void displayMessage(const std::string& message) {
	std::cout << message << std::endl;
}
```

3. **Enabling Compiler Optimizations**
	- **Optimization**: The compiler can sometimes optimize code better when it knows that certain variables are `const`. This can lead to more efficient code³.

```cpp
void calculate(const int a, const int b) {
	int result = a + b; // Compiler knows a and b won't change
	std::cout << result << std::endl;
}
```

4. **Passing by Reference**
	- **Const References**: When passing large objects or complex data structures to a function, using `const` references avoids unnecessary copying while ensuring the object is not modified².

```cpp
void processData(const std::vector<int>& data) {
	for (const auto& item : data) {
		std::cout << item << std::endl;
	}
}
```

Summary
Using `const` function parameters is a good practice to ensure safety, clarity, and potential optimizations in your code. It is especially useful when you want to prevent modifications, improve readability, and pass large objects efficiently.

¹: [Stack Overflow](1)
²: [Stack Overflow](2)
³: [EDUCBA](3)

Source: Conversation with Copilot, 2024. 8. 4.
(1) Const Keyword in C++ | Declaring a Variable or Function Parameter - EDUCBA. https://www.educba.com/const-keyword-in-c-plus-plus/.
(2) c++ - Does using const on function parameters have any effect? Why does .... https://stackoverflow.com/questions/117293/does-using-const-on-function-parameters-have-any-effect-why-does-it-not-affect.
(3) When to use const and const reference in function args?. https://stackoverflow.com/questions/3967177/when-to-use-const-and-const-reference-in-function-args.
(4) const (C++) | Microsoft Learn. https://learn.microsoft.com/en-us/cpp/cpp/const-cpp?view=msvc-170.

---

- It's generally best to avoid const function parameter unless it's pass-by-reference, which will be covered later on.

### Const return values
- It's possible to define a function and have its return value be a constant. However, it's no purpose for that and it may even generate a warning. It's best not to do it.

### Constant : object-like macros with substitution text
- In the earlier lesson [[#Object-like macros with substitution text]], we learned about preprocessing and how an identifier defined with `#define` directive can replace the identifier with a substitute text.
- The substitution text is considered a constant value, and so the object-like macros with substitution text is also named constants.
	- The value will be set on compile, and will not change during runtime.

>[!warning]
>It's best to just use constant variables over object-like macros w/ substitution text.

## Literals
- Literals are values that are inserted directly into the code (functions and such).
	- For example, `std::cout << "Hello World!";`
- Literals are sometimes called **literal constants** because their meaning cannot be redefined.
- Just like objects have a type, all literals have a type. The type of a literal is deduced from the literal's value.
	- e.g. `5` is an `int` type.
- More types can be expressed by adding a suffix to the value.
	- `f` suffix is used to indicate a literal of `float` type (e.g. `5.0f`).
	- `u` for `unsigned int`
	- `l` for `long`
	- etc..
- ![[Pasted image 20240805123926.png]]
- Most of the suffixes are not case sensitive, except:
	- `s` and `sv` must be lower case
	- Two consecutive `l` or `L` must have the same casing
- For integral types, it's generally fine to use non-suffixed `int` literals, even when initializing non-`int` types:
	- e.g. `unsigned int x = 6;` is fine, the compiler will convert it without a problem.
- By default, floating point literals have a type of `double`. To make them `float`, the `f` suffix should be used.
	- e.g. `float x = 5.1f;`
- Floating point literals can be expressed with scientific notation by using `e` followed by the power.
	- e.g. `double electronChange = 1.6e-19;` means $1.6 \times 10^{-19}$

>[!important]
>A **string** is a collection of sequential characters used to represent text. **String literals** are placed between double quotes to identify them as string (e.g. `"Hello World!"`).
>
>Because strings are commonly used in programs, most modern programming languages include a fundamental string data type. _For historical reasons, strings are not fundamental type in C++._ Rather, they have a strange, complicated type that is hard to work with (more on this in future lesson). Such strings are often called **C strings (C-Style strings)**, as they are inherited from the C-language.
>
>All C-style string literals have an implicit **null terminator** `\0`, which is used to indicate the end of the string. For example, `"Hello World!"` is actually `"Hello World!\0`". This means that the length of the string literal is longer (by one) than the characters typed (13 instead of 12 in the previous example).
>
>There are other string types such as `std::string`, which will be covered in future lessons.

- A **magic number** is a literal that either has an unclear meaning or may need to be changed later.
	- It's best practice to use variables with assigned values for readability and control. Literals, especially numbers, can seem like they came from out of nowhere, hence the "magic".

## Numeral systems (decimal, binary, hex, octal)
- **Numerical system** is a collection of symbols (e.g. digits) used to represent numbers.
- The ordinary numeral system that we use in everyday life is called **decimal numbers**, where each numerical digit can be `0` through `9`. Because there are 10 possible digits, it is called also called a **base 10**.
	- By default, numbers are assumed to be decimal.
- **Binary numbers** use two possible digits `0` or `1` per numerical digit, which makes it a **base 2**.
	- It is the numerical system that computers use internally.
	- Binary numbers are written like this: `0`, `1`, `10`, `11`, `100`, `101`, and so on.
- **Octal numbers** is **base 8**. Each numerical digit ranges from `0` to `7`
	- To use an octal literal, prefix the literal with a `0`. For example, `int x = 012;`. When this example is printed out, it prints out `10` instead because output is in decimal by default.
- **Hexadecimal** is **base 16**. Each numerical digit ranges from `0` to `F` (0123456789ABCDEF).
	- To use a hex literal, prefix the literal with `0x`. For example, `int x = 0xF;`. When this example is printed out (as decimal), it prints out `15`.

>[!important]
>Two bits are called a **crumb**, four bits are called a **nibble**, and 8 bits are called a **byte**.

### Using hexadecimal to represent binary
- Because there are 16 different values for a hexadecimal digit, we can say that a single hex digit encompasses 4 bits. Consequently, a pair of hex digits can be used to exactly represent a full byte.
	- Hex to 4 bits binary: `0x0` is `0000`, `0xF` is `1111`.
	- Hex to 8 bits binary: `0x00` is `0000 0000`, `0xFF` is `1111 1111`.
- Representing a 32-bit integer with binary numbers is rather lengthy and repetitive. In hex, however, it boils down to 8 numerical digits (which is more concise). For this reason, hex values are often used to represent memory addresses or raw data in memory.

>[!important]
>Base16, Base32, and Base64 are encoding schemes used to represent binary data in a text format. Each has its own characteristics, advantages, and trade-offs:
>
>Base16 (Hexadecimal)
>- **Encoding**: Uses 16 symbols (0-9 and A-F) to represent binary data.
>- **Efficiency**: Each byte of binary data is represented by two hexadecimal characters, resulting in a 100% increase in size.
>- **Advantages**: 
>    - Simple and easy to read.
>    - Commonly used in programming and debugging.
>- **Disadvantages**: 
>    - Less space-efficient compared to Base32 and Base64.
>    - Larger encoded size².
>
>Base32
>- **Encoding**: Uses 32 symbols (A-Z and 2-7) to represent binary data.
>- **Efficiency**: Converts five bytes (40 bits) of binary data into eight ASCII characters, resulting in a 60% increase in size.
>- **Advantages**: 
>    - More space-efficient than Base16.
>    - Case-insensitive and eliminates commonly confused characters.
>- **Disadvantages**: 
>    - Less space-efficient than Base64.
>    - Slightly more complex encoding and decoding process¹³.
>
>Base64
>- **Encoding**: Uses 64 symbols (A-Z, a-z, 0-9, +, /) to represent binary data.
>- **Efficiency**: Converts three bytes (24 bits) of binary data into four ASCII characters, resulting in a 33% increase in size.
>- **Advantages**: 
>    - Most space-efficient among the three.
>    - Widely used in email attachments, URLs, and data storage formats like XML and JSON.
>- **Disadvantages**: 
>    - Case-sensitive and includes characters that may not be URL-safe without encoding.
>    - Slightly more complex encoding and decoding process¹².
>
>Summary
>- **Base16**: Simple and easy to read, but less space-efficient.
>- **Base32**: More space-efficient than Base16, case-insensitive, but less efficient than Base64.
>- **Base64**: Most space-efficient, widely used, but case-sensitive and includes non-URL-safe characters.
>
>Each encoding scheme has its own use cases and trade-offs, so the choice depends on the specific requirements of your application.
>
>If you have any specific scenarios or further questions, feel free to ask!
>
>¹: [Base64 vs. Base32 Comparison](1)
>²: [RFC 4648](2)
>³: [Base 32 and Base 64 Encoding](3)
>
>Source: Conversation with Copilot, 2024. 8. 5.
>(1) RFC 4648: The Base16, Base32, and Base64 Data Encodings. https://www.rfc-editor.org/rfc/rfc4648.
>(2) Base64 vs. Base32 Comparison - B64Encode. https://b64encode.com/blog/base64-vs-base32-comparison/.
>(3) Base 32 and Base 64 Encoding - DZone. https://dzone.com/articles/base-32-and-base-64-encoding.

### Binary literals
- Prior to C++14, there is no support for binary literals. However, hexadecimal literals provide us with a useful workaround:

```C++
#include <iostream>

int main()
{
    int bin{};    // assume 16-bit ints
    bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable
    bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable
    bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable
    bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable
    bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable
    bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable
    bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable
    bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable
    bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable
    bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable
    bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable

    return 0;
}
```

- In C++14 onward, we can use binary literals by using the `0b` prefix:

```C++
#include <iostream>

int main()
{
    int bin{};        // assume 16-bit ints
    bin = 0b1;        // assign binary 0000 0000 0000 0001 to the variable
    bin = 0b11;       // assign binary 0000 0000 0000 0011 to the variable
    bin = 0b1010;     // assign binary 0000 0000 0000 1010 to the variable
    bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable

    return 0;
}
```

### Digit separators
- Because long literals can be hard to read, C++14 adds the ability to use a single quotation mark (apostrophe) `'` as a digit separator.
	- e.g. `1'000'000'000`
- Note that comma `,` is not used as a digit separator. This is due to the fact that it may cause confusion, as Europeans use period `.` to indicate digit separator and comma `,` for decimal point. Basically, it is a localization issue.
- The digit separator is purely visual and do not impact the literal value in any way.
	- Though it can visually represent thousands, it does not necessary change the value to thousands.
- Note that the digit separator can NOT be used before the first digit.

### Outputting values in base-8/16/32
- I/O manipulators such as `std::dec`, `std::oct`, and `std::hex` can be used to output decimal, octal, and hexadecimal values respectively.
- For example,

code
```C++
#include <iostream>

int main()
{
    int x { 12 };
    std::cout << x << '\n'; // decimal (by default)
    std::cout << std::hex << x << '\n'; // hexadecimal
    std::cout << x << '\n'; // now hexadecimal
    std::cout << std::oct << x << '\n'; // octal
    std::cout << std::dec << x << '\n'; // return to decimal
    std::cout << x << '\n'; // decimal

    return 0;
}
```

result
```console
12
c
c
14
12
12
```

- Note that once the I/O manipulator is applied, it remains set for future output until it is changed again.
- Printing binary numbers is a bit more complicated, and so it will be covered later.

## Constant expressions and compile-time optimization

### The as-if rule
- In C++, compilers are given a lot of leeway to optimize programs. The **as-if rule** says that the compiler can modify a program however it likes in order to produce more optimized code, so long as those modifications do not affect a program's observable behavior.
- Exactly how a compiler optimizes a given program is up to the compiler itself. However, there are things we can do to help the compiler optimize better.

### Compile-time evaluation of expressions
- Consider the following program:

```C++
#include <iostream>

int main()
{
	int x { 3 + 4 };
	std::cout << x << '\n';

	return 0;
}
```

- The output is straightforward, as it prints `7` every time the program runs.
- If this program was run without optimization, the compiler would generate an executable that calculates the result of `3 + 4` at runtime. If the program were executed a million times, `3 + 4` calculation would occur a million times - considering that the result of the calculation is `7` and it never changes, it is wasteful to do all that calculation over and over again when the value `7` could just be written in place.
	- A situation such as this is considered an **optimization opportunity**.
- Modern C++ compilers are able to evaluate some expressions at compile-time. When this occurs, the compiler can replace the expression with the result of the expression.
	- A simple arithmetic expression with known values (e.g. `3+4`) can be replaced with its result at compile-time.
	- **Compile-time evaluation of expressions** is considered an optimization.

### Constant expressions
- One kind of expression that can always be evaluated at compile time (and does not change during runtime) is called a **constant expression**.
	- e.g. `5`, `1.2 + 3.4`, `const int x = 5;`, `const int y = x + 3;`
	- Opposite of constant expression is runtime expression.
- A **compile-time constant** is a constant whose value must be known at compile time. This includes:
	- Literals
	- Constexpr variables (more on this later)
	- Const integral variables with a constant expression initializer (e.g. `const int x = 5;`)
	- Non-type template parameters (more on this later)
	- Enumerators (more on this later)
- Const variables that are not compile-time constants are sometimes called **runtime constants**.
	- Runtime constants cannot be used in a constant expression.
	- e.g. `int x = 5;`, `const int y = x;` (`x` is not a constant variable)
- Note that `<<` operator does NOT support compile-time evaluation, because output can't be done at compile-time.

### Usefulness of constant expressions
- Constant expressions are useful for (at least) three reasons:
	- Constant expressions are most likely to be optimized.
	- Both the type and the value is known at compile-time, which means any errors associated with constant expressions can be caught at compile-time. This makes it comparably easier to test and safer than catching errors during runtime.
	- Constant expressions are useful for keeping things memory safe by setting certain values to a fixed amount (that cannot be changed).

### Partial optimization of constant subexpressions
- When a part of a runtime expression consists of a constant subexpression, that constant subexpression can be optimized.
	- e.g. `std::cout << 3 + 4;` is a runtime expression, but `3 + 4` is a constant subexpression. `3 + 4` can be optimized by replacing it with `7`.

### Optimization of non-constant expressions
- Compilers are capable of optimizing non-constant expressions in certain cases.
- When a variable is initialized and its value does not change throughout the whole program, the compiler may choose to replace the variable with its value wherever the variable is called. Furthermore, the variable may be removed (**optimized out/away**).
- For example,

Before optimization
```C++
#include <iostream>

int main()
{
	int x { 7 };
	std::cout << x << '\n';

	return 0;
}
```

After optimization
```C++
#include <iostream>

int main()
{
	std::cout << 7 << '\n';

	return 0;
}
```

- This kind of optimization only happens if the compiler realizes that the value of a variable does not change. Whether the compiler realizes this comes down to how complex the program is, and how sophisticated the compiler's optimization routines are.
- Note that it's worth considering changing the non-constant variable to a constant variable if its value does not change. Then it's guaranteed that the compiler will optimize the code accordingly.

### Optimization can make programs harder to debug
- When the compiler optimizes a program, variables/expressions/statements/function calls may be rearranged/altered/replaced with a value/removed. Such changes can make it hard to debug a program effectively.
- There are times when optimization itself can cause a bug; like when a variable/expression is replaced with a wrong value.
- To help minimize such issues with debugging, debug builds will typically turn down (or off) optimizations, so that the compiled code will closely match the source code.

## Constexpr variables
### Problem with const
- When using `const`, integral variables may end up as either a compile-time const or a runtime const, depending on whether the initializer is a constant expression or not.
	- In some cases, this can make it hard to tell whether the `const` variable is actually a compile-time constant or not.
- The use of `const` to create a compile-time constant variables does not extend to non-integral variables.

### The constexpr keyword
- `constexpr` keyword (shorthand for constant expression) can be used instead of `const` to make sure the variable is declared as a compile-time constant variable; as such, a `constexpr` variable is always a compile-time constant.
	- As a result, a `constexpr` variable must be initialized with a constant expression, otherwise a compilation error will result.
- For example,

```C++
#include <iostream>

int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
    constexpr int something { sum };  // ok: sum is a constant expression

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // compile error: age is not a constant expression
    constexpr int f { five() };       // compile error: return value of five() is not a constant expression

    return 0;
}
```

- Additionally, `constexpr` works for both integral and non-integral types.

### Const vs. constexpr
- `const` means that the value of an object cannot be changed after initialization. The value of the initializer may be known at compile-time or runtime. The object can be evaluated at runtime.
- `constexpr` means that the object can be used in a constant expression. The value of the initializer must be known at compile-time. The object can be evaluated at runtime or compile-time.
- `constexpr` variables are implicitly `const`. However, it's not true for the other way around.
- Defining a variable as both `constexpr` and `const` is possible but it is redundant in most cases.

### Const and constexpr function parameters
- Normal function calls are evaluated at runtime, with the supplied arguments being used to initialize the function's parameters. Because the initialization of function parameters happens at runtime, this leads to two consequences:
	- `const` function parameters are treated as runtime constants (even when the supplied argument is a compile-time constant).
	- Function parameters cannot be declared as `constexpr`, since their initialization value isn't determined until runtime.
- C++ does support functions that can be evaluated at compile-time. This will be discussed in future lessons.

## The conditional operator
- The **conditional operator** `?:` (aka arithmetic if operator) is a ternary operator (takes 3 operands) that provides a shorthand method for doing a particular type of if-else statement.
- To recap, an if-else statement takes the following form:

```C++
if (condition)
	statement1;
else
	statement2;
```

- The `?:` operator takes the following form:

```C++
condition ? expression1 : expression2;
```

- If `condition` evaluates to `true`, then `expression1` is evaluated, else `epxression2`.
	- The `:` and `expression2` are not optional.
- Consider an if-else statement that looks like this:

```C++
if (x > y)
	greater = x;
else
	greater = y;
```

- Above if-else statement can be rewritten as:

```C++
greater = ((x > y) ? x : y);
```

- Using the conditional operator can help compact code without losing readability.

### The conditional operator as an expression
- The conditional operator and its operands are considered an expression, therefore it can be used in places where an expression is required.
- For example, the conditional operator can be used for initializing a variable:

```C++
#include <iostream>

int main()
{
    constexpr bool inBigClassroom { false };
    constexpr int classSize { inBigClassroom ? 30 : 20 };
    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```

- There is no direct if-else replacement for the example above. Consider the following:

```C++
#include <iostream>

int main()
{
    constexpr bool inBigClassroom { false };

    if (inBigClassroom)
        constexpr int classSize { 30 };
    else
        constexpr int classSize { 20 };

    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```

- The code above will not compile because `classSize` will only exist within the scope of the conditional statement, meaning that printing its value will result in undefined variable error.
	- Declaring `classSize` outside the if-else block will not work, as its intended purpose is to be a `constexpr` variable, which means it has to be initialized with a value at definition.
- Like the example above, the conditional operator is useful for situations where if-else logic must be contained within the initializer.

>[!important] Parenthesizing the conditional operator
>Because operators have a certain order of priority and most operators are prioritized over the evaluation of the conditional operator, it's recommended to use parenthesis on the conditional operator (either the entire expression or the condition) to make it more readable and clear.
>
>Follow these two rules:
>- Parenthesize the entire conditional operator when used in a compound expression (an expression with other operators).
>- Parenthesize the condition if it contains any operators (other than the function call operator).

>[!warning] Operant types must match (or be convertible)
>When using a conditional operator, the type of the second and third operand must match, otherwise one of the operands will be converted to match the other. Such conversions may yield undefined behaviors.
>
>In general, it's okay to mix operands with fundamental types. But it's best to avoid mixing signed and unsigned values.
>- Mixing `int` and `float` is okay, as `int` operand will be converted to `float`.
>- Consider `(true ? -1 : 2u)`, where `-1` is converted to `unsigned int` to match the type of the other; which causes the overflow wrap-around to occur.
>
> A compile error will result if the types are not convertible. For example, mixing `int` and C-style string (e.g. `"Hello World!"`) will result in compile error.
> 
> If either operand is not a fundamental type, it's generally best to explicitly convert one or both operands to a matching type.

- It's best to avoid using conditional operator in complicated expressions, as they tend to be error prone and hard to read.

## Inline functions and variables
### Function overhead
- Writing functions provides many potential benefits, as code in a function:
	- Easy to read and understand in the context of the overall program.
	- Easy to use, as you can call the function without understanding how it is implemented.
	- Easy to update, as the function can be updated in one place
	- Easy to reuse, as functions are naturally modular
- One downside of using a function is that every time a function is called, there is a certain amount of performance **overhead** (extra work that must happen to facilitate a function) that occurs:
	- When a function is called, the CPU must store the address of the current instruction it is executing, so it knows where to return to later.
	- The function parameters must be instantiated and then initialized.
	- When the function ends, the program has to jump back to the location of the function call, and then the return value ahs to be copied so it can be output.
- For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run.
	- However, for small functions, the overhead costs can be larger than the time needed to actually execute the function's code. In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.

### Inline expansion
- The compiler has a trick that it can use to avoid function overhead; **inline expansion** is a process where a function call is replaced by the code from the called function's definition.
- For example,

Before inline expansion
```C++
#include <iostream>

int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

After
```C++
#include <iostream>

int main()
{
    std::cout << ((5 < 6) ? 5 : 6) << '\n';
    std::cout << ((3 < 2) ? 3 : 2) << '\n';
    return 0;
}
```

- Beyond removing the cost of function call (overhead), inline expansion can also allow the compiler to optimize the resulting code more efficiently.
	- If a function becomes a constant expression due to inline expansion, the compiler could further optimize the code by optimizing out the constant expression with a value.
- Inline expansion has its own potential cost - if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in memory caches).
- The decision about whether a function would benefit from being made inline is not straightforward. Inline expansion is best suited to simple, short functions (no more than a few statements), especially cases where a single function call can be executed more than once (e.g. function calls inside a loop).

### Historical use of inline keyword
- Historically, compilers either didn't have the capability to determine whether inline expansion would be beneficial or were not very good at it. For this reason, C++ provided the keyword `inline`, which was originally intended to be used as a hint to the compiler that a function would (probably) benefit from being expanded inline.
- A function that is declared using the `inline` keyword is called an **inline function**.
- An example of inline function:

```C++
#include <iostream>

inline int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```

>[!warning] The `inline` keyword is no longer used in modern C++ for inline expansion.
>The `inline` keyword is no longer used in modern C++ because of a few reasons:
>- Using `inline` to request inline expansion is a form of premature optimization, and misuse could actually harm performance.
>- The `inline` keyword is just a hint. The compiler is completely free to ignore it.
>- The `inline` keyword is defined at the wrong level of granularity; `inline` keyword is used on a function definition, but inline expansion is actually determined per function call.

### Modern use of inline keyword
- In modern C++, the term `inline` has evolved to mean "multiple definitions are allowed". Thus, an **inline function** is one that is allowed to be defined in multiple translation units (without violating the ODR).
- Inline functions have two primary requirements:
	- The compiler needs to be able to see the *full definition* of an inline function in each translation unit where the function is used (a forward declaration will not suffice on its own). The definition can occur after the point of use if a forward declaration is also provided. Only one such definition can occur per translation unit, otherwise a compilation error will occur.
	- Every definition for an inline function must be *identical*, otherwise undefined behavior will result.
- For example,

main.cpp
```C++
#include <iostream>

double circumference(double radius); // forward declaration

inline double pi() { return 3.14159; }

int main()
{
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```

math.cpp
```C++
inline double pi() { return 3.14159; }

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```

- Inline functions are typically defined in header files, where they can be `#included` into the top of any code file that needs to see the full definition of the identifier. This ensures that all inline definitions for an identifier are identical.
- For example,

pi.h
```C++
#ifndef PI_H
#define PI_H

inline double pi() { return 3.14159; }

#endif
```

main.cpp
```C++
#include "pi.h" // will include a copy of pi() here
#include <iostream>

double circumference(double radius); // forward declaration

int main()
{
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```

math.cpp
```C++
#include "pi.h" // will include a copy of pi() here

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```

- Inline functions (defined in header files) are particularly useful for header-only libraries, which are one or more header files that implement some capability (no .cpp files are included).
	- Header-only libraries are popular because there are no source files that need to be added to a project to use them (and be linked). You simply `#include` the header-only library and then can use it.

>[!important]
>There are a couple reasons why not all functions are inline and defined in a header file:
>- It can increase the compile time. When a function in a code file changes, only that code file needs to be recompiled. When an inline function in a header file changes, every code file that includes that header (either directly or via another header) needs to be recompiled. On large projects, this can have a drastic impact.
>- It can lead to more naming collisions since you'll end up with more code in a single code file.

### Inline variables (C++17)
- C++17 introduces **inline variables**, which are variables that are allowed to be defined in multiple files.
	- Inline variables work similarly to inline functions, and have the same requirements.
- Common use for inline variables will be covered later as it will relate to the topic of sharing global constants across multiple files.

## Constexpr and consteval functions
- One challenge with constant expressions is that function call to a normal function are not allowed in constant expressions. This means we cannot use such function calls anywhere a constant expression is required.
- For example:

```C++
#include <iostream>

double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) };

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```

- The code above will result in a compile error, because `circumference` requires that its initializer is a constant expression, and the call `calcCircumference()` isn't a constant expression.

### Constexpr functions
- A **constexpr function** is a function that is allowed to be called in a constant expression.
	- To make a function a constexpr function, simply place the `constexpr` keyword in front of the function's return type.
- For example,

```C++
#include <iostream>

constexpr double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) };

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```

- If a required constant expression contains a constexpr function call, that constexpr function call must evaluate at compile-time.
	- In the example above, `calcCircumference()` is evaluated at compile-time; the return value of the function call is calculated at compile-time, and then the function call is replaced with the return value (e.g. `constexpr double circumference { 18.8496 };`)
- To evaluate at compile-time, two other things must also be true:
	- The arguments to the constexpr function call must be known at compile time
	- All statements and expressions within the constexpr function must be evaluatable at compile-time.

>[!important]
>Constexpr functions can also be evaluated at runtime, in which case they will return a non-constexpr result.
>
>One of the cases where a constexpr function is evaluated at runtime is when the arguments to the call are not constant expressions.
>
>Another case is when the constexpr function call is part of a non-required constant expression.

>[!warning]
>The parameters of a constexpr function are not implicitly constexpr, nor may they be declared as `constexpr`.
>
>If a constexpr function is given constexpr arguments, then the function will be evaluated at compile-time. However, if a constexpr function is given arguments that are not constexpr, then the function will be evaluated at runtime.

### Constexpr functions are implicitly inline
- When a constexpr function is evaluated at compile-time, the compiler must be able to see the full definition of the constexpr function prior to such function calls.
	- A forward declaration will not suffice in this case, even if the actual function definition appears later in the same compilation unit.
- A constexpr function called in multiple files needs to have its definition included into each translation unit.
	- This would normally be a violation of the ODR, but constexpr functions are implicitly inline (which makes them exempt).
- Because constexpr functions are implicitly inline, they are often defined in header files, so they can be `#included` into any .cpp file that requires the full definition.

### Consteval (C++20)
- C++20 introduces the keyword `consteval`, which is used to indicate that a function MUST evaluate at compile-time, otherwise a compile error will result.
	- Such functions are called **immediate functions**.
- For example,

```C++
#include <iostream>

consteval int greater(int x, int y) // function is now consteval
{
    return (x > y ? x : y);
}

int main()
{
	// ok: will evaluate at compile-time
    constexpr int g { greater(5, 6) };
    std::cout << g << '\n';

	// ok: will evaluate at compile-time
    std::cout << greater(5, 6) << " is greater!\n";

    int x{ 5 }; // not constexpr
    // error: consteval functions must evaluate at compile-time
    std::cout << greater(x, 6) << " is greater!\n";

    return 0;
}
```

- Note that the parameters of a consteval function are not constexpr.
	- Even though consteval functions can only be evaluated at compile-time (meaning they can only accept constexpr arguments), this decision was made for the sake of consistency.

### Using consteval to make constexpr execute at compile-time (C++20)
- The downside of consteval functions is that such functions can't evaluate at runtime, making them less flexible than constexpr functions (which can do either).
	- The downside of constexpr function is that it does not guarantee evaluation at compile-time.
- One way to get around the issue(s) mentioned above, is to use constexpr function with a consteval function as a helper function.
- For example,

```C++
#include <iostream>

consteval auto compileTimeEval(auto value)
{
    return value;
}

constexpr int greater(int x, int y)
{
    return (x > y ? x : y);
}

int main()
{
	// may or may not execute at compile-time
    std::cout << greater(5, 6) << '\n';
    // will execute at compile-time
    std::cout << compileTimeEval(greater(5, 6)) << '\n';

    int x { 5 };
    // we can still call the constexpr version at runtime if we wish
    std::cout << greater(x, 6) << '\n';

    return 0;
}
```

- This workaround works because consteval functions require constant expressions arguments. Therefore, if the return value of a constexpr function is used as an argument to a consteval function, the constexpr function must be evaluated at compile-time.
- Note that while it may seem like inefficient to set up a consteval function that simply returns a value that it's given, it doesn't matter because the entire call to the consteval function willy simply be replaced with the calculated return value.
- `auto` return type allows a function to work with any type of value. This will be covered more later on.

### Constexpr/consteval functions can use non-const local variables
- Within a constexpr or consteval function, local variables that are non-constexpr can be used.
	- Non-constexpr, meaning that the values of these local variables can be changed.
	- However, initializing the variables with a return value of a non-constexpr function may make the constexpr function to be evaluated at runtime; compile error in consteval function case.
- For example,

```C++
#include <iostream>

consteval int doSomething(int x, int y) // function is consteval
{
    x = x + 2;       // we can modify the value of non-const function parameters

    int z { x + y }; // we can instantiate non-const local variables
    if (x > y)
        z = z - 1;   // and then modify their values

    return z;
}

int main()
{
    constexpr int g { doSomething(5, 6) };
    std::cout << g << '\n';

    return 0;
}
```

### Function parameters and local variables as arguments
- Function parameters and local variables inside a constexpr/consteval function can be used as arguments for another constexpr/consteval function inside that function.
	- Both of these functions will be evaluated at compile-time.
	- Note that a constexpr/consteval function can call another constexpr/consteval function.
- For example,

```C++
#include <iostream>

constexpr int goo(int c)
{
    return c;
}

constexpr int foo(int b)
{
    return goo(b);
}

int main()
{
    std::cout << foo(5);

    return 0;
}
```

### A constexpr function can call a non-constexpr function
- A constexpr function can call a non-constexpr function, but only when the constexpr function is being evaluated in a non-constant context.
- Calling a non-constexpr function is allowed so that a constexpr function can do something like this:

```C++
#include <type_traits> // for std::is_constant_evaluated

constexpr int someFunction()
{
    if (std::is_constant_evaluated()) // if evaluating in constant context
        return someConstexprFcn();
    else
        return someNonConstexprFcn();
}
```

- Though it's allowed, it's best to avoid calling non-constexpr functions from within a constexpr function if possible.
- Like the example above, if a constexpr function requires different behavior for constant and non-constant contexts, conditionalize the behavior with `if (std::is_constant_evaluated())` (in C++20) or `if consteval` (C++23 onward).

>[!warning] Always test your constexpr functions in a constant context.

### Why not constexpr every function?
- There are a few things to consider before making a function `constexpr`:
	- Not all functions can be evaluated as part of a constant expression.
	- `constexpr` function is used in contexts that require constant expressions. Make sure that the constexpr function is absolutely necessary, as removing the `constexpr` later will break the code.
	- `constexpr` function is harder to debug due to optimization & can't be inspected at runtime.

>[!important]
>Though one should be careful not to make every functions unnecessarily `constexpr`, it's still a good idea to make a function `constexpr` if that function can be evaluated as part of a constant expression.

## Intro to string types
- C-style string literals (as covered previously on [[#Literals]]) refers to a text in between double quotation marks with a hidden null terminator.
- While C-style string literals are fine to use, C-style string variables are best avoided in modern C++ because they behave oddly, are hard to work with, and are dangerous.
- C++ has introduced two additional string types into the language that are much easier and safer to work with; `std::string` and `std::string_view` (C++17).
	- These are not fundamental types.

### Intro to std::string
- The easiest way to work with strings and string objects in C++ is via the `std::string` type, which lives in the `<string>` header.
- For example,

```C++
#include <string>

int main()
{
	std::string name = "Alex";
	name = "John";

	return 0;
}
```

- `std::string` objects can be printed to console by using `std::cout`.
	- e.g. `std::cout << name;`
	- Empty strings will print nothing.
- `std::string` uses **dynamic memory allocation**, meaning that it's able to allocate different amount of memory depending on the length of the string being stored.
	- In other words, `std::string` is able to store strings of different lengths.
	- Although dynamic memory allocation makes `std::string` so flexible compared to `char`, it is also comparatively slow.

### String input with std::cin
- One of the things that you need to watch out for when using `std::string` with `std::cin` and `>>` operator, is that `>>` operator only returns characters up to the first whitespace it encounters.
- For example,

```C++
#include <iostream>
#include <string>

int main()
{
    std::cout << "Enter your full name: ";
    std::string name{};
    std::cin >> name;

    std::cout << "Enter your favorite color: ";
    std::string color{};
    std::cin >> color;

    std::cout << "Your name is " << name << " and your favorite color is " << color << '\n';

    return 0;
}
```

- In the example above, if `John Doe` is entered when asked for the full name, `"John"` gets assigned to `name` and `"Doe"` gets left inside the `std::cin` buffer. When asked for the favorite color, `std::cin` will skip waiting for user input and `"Doe"` gets assigned to `color`.
	- In the end, the last sentence that gets printed out is `"Your name is John and your favorite color is Doe"`.

### String input with std::getline()
- To read a full line of input into a string, `std::getline()` is used instead.
- `std::getline()` requires two arguments:
	- Input stream (e.g. `std::cin`)
	- String variable (e.g. `std::string text`)
- An example:

```C++
#include <iostream>
#include <string>

int main()
{
	std::cout << "Enter your full name: ";
	std::string name;
	std::getline(std::cin, name);
	std::cout << "Hello, " << name << "!";

	return 0;
}
```

```console
Enter your full name: John Doe
Hello, John Doe!
```

- It's good practice to use `std::cin >> std::ws` as the first argument to `std::getline()` because the input manipulator `std::ws` makes it so that `std::cin` ignores any leading whitespace before extraction.
	- Usually this won't be a problem if only `std::getline()` is being used, but there's a possibility that a whitespace is sitting in the input buffer if `std::cin >>` was used.
- For example:

```C++
#include <iostream>
#include <string>

int main()
{
    std::cout << "Pick 1 or 2: ";
    int choice{};
    std::cin >> choice;

    std::cout << "Now enter your name: ";
    std::string name{};
    std::getline(std::cin, name); // note: no std::ws here

    std::cout << "Hello, " << name << ", you picked " << choice << '\n';

    return 0;
}
```

```console
Pick 1 or 2: 2
Now enter your name: Hello, , you picked 2
```

- In the example above, `2\n` was entered; `2` was assigned to `choice` and `\n` remained inside `sdt::cin`. When asked for `name`, `std::getline()` skipped waiting for user input as it ended up extracting `\n` and assigning it to `name`.
	- This problem is easily fixed by `std::getline(std::cin >> std::ws, name);`

### The length of a std::string variable
- `std::string` includes a member function `.length()` that returns the object's current length.
	- More about member function later.
	- It's written as `std::string::length()` in documentation.
- For example,

```C++
std::string name = "name";
std::cout << name.length(); // prints 4
```

- Although `std::string` is required to be null-terminated (as of C++11), the returned length of a `std::string` does not include the implicit null-terminator character.
- Note that `std::string::length()` returns an unsigned integral value (most likely of type `size_t`).
	- Use `static_cast<int>(var)` if assigning the value to `int` variable
- (C++20) `std::ssize()` function can also be used to get the length of a `std::string` as a large signed integral type (usually `std::ptrdiff_t`).

### Initializing a std::string is expensive
- Whenever a `std::string` variable is initialized, a copy of the string (used to initialize) is made.
	- Making copies of strings is expensive, so care should be taken to minimize the number of copies made.

>[!warning] Do not pass `std::string` by value, as it makes an expensive copy.

>[!warning] Do not return `std::string` by value, as it makes an expensive copy.

- Passing and returning `std::string` properly will be discussed later on, when discussing `std::string_view` and pass/return-by-reference.

### std::string literals (C++14)
- Double-quoted string literals (e.g. "Hello World!") are C-style strings by default (and thus, have a strange type).
	- Assigning a double-quoted string literal to a `std::string` type variable incurs an implicit conversion.
- String literals with type `std::string` is a double-quote string literal with `s` suffix.
	- For example, `std::string name = "John Doe"s;`
- In order to use the `s` suffix (easy access, so to say), `using namespace std::string_literals;` must be stated.
	- Another way is `using namespace std::literals;` but this also imports all of the standard library literals into the scope (which won't likely be used).
	- `using` directives will be covered later. Just know that it allows for a namespace to be opened to the global scope, allowing its types, functions, and all other stuff to be used easily (without stating the namespace over and over).

>[!important]
>Another way to assign string literals to `std::string` types is using the `std::string` constructor with a `const char*` argument. For example,
>```C++
>std::string name = std::string("John Doe");
>```
>This way avoids implicit conversion, and just as efficient as using the `std::string` literal (the `s` suffix).

- Note that it's not super important to use `std::string` literals to initialize a `std::string` variable, as it is fine to do with C-style string literal.
	- However, there are some advantages that will be discussed later.

### Constexpr strings (Don't)
- If you try to define a `constexpr std::string`, your compiler will probably generate an error.
	- This happens because it isn't supported at all in C++17 or earlier, and only works in very limited cases in C++20/23.

## Intro to std::string_view (C++17)
- Using `std::string` can be expensive because it makes copies of its initializer.
	- For example, in a statement such as `std::string name = "John Doe";`, the C-style string literal `"John Doe"` is copied into memory.
	- Unlike fundamental types, initializing and copying a `std::string` is slow.
- The expensive copy happens again when a `std::string` object is passed to a function as an argument, because the parameter (which is `std::string`) is initialized (which means another copy).
- To address the issue with `std::string` being expensive to initialize/copy, `std::string_view` (which lives in the `<string_view>` header) was introduced.
- `std::string_view` provides read-only access to an existing string (a C-style string, a `std::string`, or another) without making a copy.
	- **Read-only** means that the value can be accessed and viewed but cannot be modified. Another word for it is **immutable**.
	- The size of a `std::string_view` is fixed at the time of its creation, and cannot be changed.
- What makes `std::string_view` so much lighter than `std::string` is the fact that it does not own the string data. It merely provides a lightweight view into an existing string, and it does not manage memory (no allocation/deallocation).
- `std::string_view` is flexible in a way that it can be initialized from nearly anything; a C-style string, a `std::string`, or another `std::string_view`.
- For example,

```C++
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string_view s1 { "Hello, world!" }; // initialize with C-style string literal
    std::cout << s1 << '\n';

    std::string s{ "Hello, world!" };
    std::string_view s2 { s };  // initialize with std::string
    std::cout << s2 << '\n';

    std::string_view s3 { s2 }; // initialize with std::string_view
    std::cout << s3 << '\n';

    return 0;
}
```

- `std::string_view` can be initialized from any kind of string because it merely creates a view into the memory occupied by the content.
	- It extends to

>[!warning] Problem with non-ownership
>When a `std::string_view` is initialized with a variable, it creates a view into the memory occupied by that variable. If the variable is changed or removed, the `std::string_view` can become invalid or point to unintended data.
>
>To avoid such issues, ensure that the lifetime of the original variable exceeds the lifetime of the `std::string_view`. Alternatively, just use different string type.




