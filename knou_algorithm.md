# 알고리즘

## 1. 알고리즘 소개
> [!info]- 개요
> 이 장에서는 앞으로 교재에서 다룰 다양한 알고리즘을 설계하고 분석하는데 반드시 필요한 기본적인 내용을 다룬다. 우선 알고리즘의 정의와 중요성에서부터 시작하여, 기본적인 자료구조의 개념과 특징 등에 대해서 개괄적으로 살펴본 다음, 알고리즘의 성능을 분석하고 표기하는 방법을 중심으로 학습한다.

> [!important]- 학습목표
> 1. 알고리즘의 중요성과 개념을 이해할 수 있다.
> 2. 기본 자료구조의 개념과 특성을 이해하고, 알고리즘 설계에 활용할 수 있다.
> 3. 알고리즘의 분석 방법과 점근성능의 표기법을 이해하고 적용할 수 있다.
> 4. 순환 알고리즘의 개념과 주요 점화식의 의미를 이해할 수 있다.

> [!warning]- 주요 용어
> 알고리즘 / 배열 / 연결 리스트 / 스택 / 큐 / 트리 / 그래프 / 공간 복잡도 / 시간 복잡도 / 점근성능 / O-표기 / Ω-표기 / Θ-표기 / 점화식

### 1.1 알고리즘의 개념
- **알고리즘(Algorithm)** 은 문제 해결을 위한 조리법(Recipe)라고 할 수 있다. 조리법이 식재료를 사용해서 음식을 만들기 위한 일련의 단계적인 과정을 나타낸 것이라면, 알고리즘은 주어진 문제를 해결하기 위한 일련의 처리 과정을 단계적으로 나열한 것이다. 즉, 레시피의 단계적인 절차를 따르면 요리가 만들어지듯이, 알고리즘의 단계적인 절차를 따르면 주어진 문제의 해를 구할 수 있다.

> [!info]- 예제 1 : 최댓값 찾기 문제
> 문제 : 주어진 숫자(25, 15, 35, 60, 45, 80, 55, 75) 중에서 최댓값을 찾는 문제를 해결하는 알고리즘을 표현하시오.
> 풀이 : 최대값 찾기 문제의 가장 기본적인 해결 방법은 각 숫자를 하나씩 모두 비교하는 것으로서, 이를 위한 단계적인 처리 과정은 일상적인 언어를 사용해서 밑에 그림과 같이 기술할 수 있다.
> ![[Pasted image 20230524164224.png|500]]

> [!info]- 예제 2 : 한붓 그리기 문제
> 문제 : 스마트폰의 앱 중에 한붓 그리기라는 것이 있다. 이것은 밑에 그림과 같은 그래프를 대상으로 한 점에서 출발해서 펜을 떼지 않고 모든 선분을 한번씩만 지나는 경로를 찾는 것이다. 단, 각 점은 여러 번 방문해도 무관하다.
> ![[Pasted image 20230524164519.png|500]]
> 풀이 : 한붓 그리기가 가능하려면 각 정점의 차수(각 점에 연결된 선분의 개수)가 홀수인 점이 없거나 두 개여야 하며, 홀수점이 두 개일 경우에는 홀수점에서 시작해야 한다. 특히 홀수점이 없는 경우에는 출발점과 도착점이 같은 (오일러) 회로가 형성된다.
> > [!info] (a) 그래프 풀이
> > 정점 4와 5가 홀수점이기 때문에 정점 4 또는 정점 5에서 시작해야만 한붓 그리기가 가능함.
> 
> > [!info] (b) 그래프 풀이
> > 홀수점이 4 개(정점 1,2,4,5)이기 때문에 한 붓 그리기를 할 수 없다.

> [!info]- 예제 3 : 단일 출발점 최단 경로 문제
> 문제 : 서울에서 부산까지 고속도로를 이용하여 가려고 한다. 가장 짧은 거리(또는 가장 적은 시간)이 걸리는 길을 찾아서 이동하려면 어떤 경로를 선택해야 하는가? 밑에 그림에서 각 간선 옆에 표시된 숫자는 도시 간의 이동 거리 또는 이동 시간을 나타낸다.
> ![[Pasted image 20230524165402.png|500]]
> 풀이 : 이것은 하나의 출발점에서 다른 모든 정점(도시)으로의 최단 경로를 구하는 문제로, 다익스트라(Dijkstra) 알고리즘으로 해결 가능하다. 그림에서 각 정점 옆에 표시된 숫자는 서울에서 해당 도시에 이르는 최소 거리를 다익스트라 알고리즘으로 계산한 것이다. 계산된 최소 거리를 기준으로 서울-부산 간의 최단 경로는 서울-천안-논산-대전-진주-부산 이다.

- 알고리즘이라는 용어는 **컴퓨터과학(Computer Science, CS)** 분야에서 많이 접하게 되는데, 도대체 알고리즘은 CS에서 어떤 의미와 위치를 차지하고 있는가?
	- CS는 컴퓨터를 활용해서 문제를 해결하기 위한 분야라고 간단히 정의할 수 있다.
		- 문서 작업, 데이터 검색 및 분석, 게임 등 컴퓨터를 사용하는 개별적인 목적은 다를 수 있지만, 기본적으로는 주어진 문제를 보다 효율적으로 해결하기 위해서 컴퓨터를 활용한다.
	- 컴퓨터에서의 작업은 문제 해결에 적합한 프로그램을 이용해야만 처리할 수 있다.
	- 프로그램(Program)이란 주어진 문제의 입력 데이터를 조작하여 원하는 결과를 생성하기 위한, 컴퓨터가 이해할 수 있는 명령어들의 집합이다.
		- 프로그램의 각 명령어가 지시하는 대로 컴퓨터의 요소들을 조작하여 데이터로부터 정보를 생성한다.
		- 올바른 입력과 정확한 프로그램이 존재한다면 컴퓨터를 통해 항상 유용한 결과를 얻을 수 있다.
			- 만약 유효한 입력이 제공되더라도 이를 처리할 수 있는 정확한 프로그램이 존재하지 않는 경우에는 어떻게 될까?
				- 주어진 데이터를 어떻게 처리해야 하는지를 컴퓨터에 지시할 수 없기 때문에 컴퓨터를 이용해서 주어진 문제를 해결하는 것은 불가능하다.
				- 올바른 프로그램이 존재하지 않으면 컴퓨터는 문제 해결에 아무런 도움도 되지 않는 쓸모없는 기계에 불과하다.
	- 프로그램은 알고리즘을 코딩한 결과로 얻어진 것이다.
	- 주어진 문제를 풀어 원하는 해를 얻으려면 어떤 일련의 절차를 거쳐서 해결할 것인가를 나타내는 문제의 풀이 과정이 반드시 필요하며, 이러한 일련의 처리 과정이 바로 알고리즘이다.
	- 주어진 문제를 푸는 알고리즘이 없으면 프로그램을 작성할 수 없고, 프로그램이 없으면 결국 컴퓨터를 이용한 자료 처리는 불가능하기 때문에 CS를 알고리즘과 관련된 이슈를 다루는 학문이라고 정의하기도 한다.

#### 1.1.1 알고리즘의 정의
- 개념적으로 알고리즘은 주어진 문제를 풀기 위한 명령어를 단계적으로 나열한 것이라고 생각할 수 있다. 하지만 컴퓨터를 통한 문제 해결의 가능성이라는 측면에서 보면 알고리즘의 각 명령어(연산)들에 약간의 제한이 추가되어야 하며, 따라서 알고리즘은 다음 조건을 만족한다.
	- **입출력 (Input & Output)** : $0$ 개 이상의 외부 입력과 $1$ 개 이상의 출력이 있어야 한다.
	- **명확성 (Definiteness)** : 각 명령은 모호하지 않고 단순 명확해야 한다.
	- **유한성 (Finiteness)** : 한정된 수의 단계를 거친 후에는 반드시 종료해야 한다.
	- **유효성 (Effectiveness)** : 모든 명령은 컴퓨터에서 수행 가능해야 한다.
- 앞의 조건을 종합해서 알고리즘을 다시 정의하면, 알고리즘은 "주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령들을 순서적으로 구성한 것"이라고 할 수 있다.
- 어떤 문제에 대해서 앞에서 언급한 조건을 만족하는 알고리즘이 존재한다는 것은 주어진 입력에 대해 유한 시간 내에 원하는 결과를 생성하는 프로그램이 존재한다는 것을 의미하고, 이는 주어진 문제가 궁극적으로 컴퓨터로 해결될 수 있음을 나타낸다.
- 하지만 알고리즘이 존재하는 문제일지라도, 컴퓨터를 이용해서 해결하는데 현실적으로는 처리 결과를 기다릴 수 없을 정도로 긴 처리 시간을 요구하는 문제도 있다.
	- 즉, 이론적으로는 알고리즘이 존재해서 해결이 가능하지만 효율적으로 풀 수 없는 문제도 있다는 것이다.
	- 따라서, 실용적인 관점에서 보면 효율성은 충분히 고려되고 만족되어야 할 중요한 조건임에 틀림없다.

#### 1.1.2 알고리즘의 생성
- 알고리즘을 생성하려면 일련의 과정을 거쳐야 한다.
	- 우선, 주어진 문제의 입출력 조건과 처리 조건 등을 분석해서 알고리즘을 설계한다.
	- 설계가 완료된 알고리즘은 적절한 방법으로 표현한다.
	- 안정성을 검토하기 위해 알고리즘의 정확성과 효율성을 분석한다.
- 설계된 알고리즘은 일상적인 언어, 순서도(Flow Chart), 의사 코드 (Pseudo Code) 등의 다양한 방법을 사용해서 표현되고 기술될 수 있다.
	- 하지만, 정확한 처리 과정의 표현과 데이터 구조의 명시 및 컴퓨터로의 구현을 고려해서 프로그래밍 언어를 사용해서 표현하는 경우가 많다.
	- ![[Pasted image 20230524172418.png|500]]

### 1.2 기본 자료구조
- 컴퓨터를 이용해서 주어진 문제를 해결하려면 우선 해당 문제를 컴퓨터가 처리할 수 있는 형태로 표현해야 한다.
	- 자료구조(Data Structure)는 컴퓨터 기억공간 내에 자료를 표현하고 조직화하는 방법을 의미한다.
	- 사용하는 데이터 양과 연산, 필요한 기억장치의 양, 원하는 작업에 대한 처리 시간, 데이터의 성격 등을 고려해서 문제에 맞는 적절한 자료구조를 선택해야만 보다 효율적으로 자료를 처리할 수 있다.
- 자료구조와 알고리즘은 어떤 관계일까?
	- 좋은 프로그램을 만들려면 자료구조와 알고리즘이 적절히 조화를 이루어야 한다.
	- 자료구조에 대한 고려 없는 알고리즘의 선택은 의미가 없다. 반대로, 알고리즘에 대한 고려 없는 자료구조의 선택이라는 것도 마찬가지로 의미가 없다.
	- 복잡하더라도 적절한 자료구조를 선택하면 알고리즘은 보다 효율적인 처리 과정들로 구성될 수 있다.
	- 간단하더라도 부적절한 자료구조를 선택하면 알고리즘은 상대적으로 복잡해지고 비효율적이 될 수 있다.
	- 결국 주어진 문제에 적합한 자료구조의 선택이 알고리즘의 설계 및 효율에 큰 영향을 미친다.
- 기본적인 자료구조
	- 알고리즘을 표현하고 구현함에 자료구조가 사용되기 때문에 알고리즘을 본격적으로 살펴보기 전에 기본 자료구조의 주요 내용을 확실히 정리해야 한다.
	- 선형 자료구조 - 배열, 연결 리스트, 큐, 스택
	- 비선형 자료구조 - 트리, 그래프

#### 1.2.1 배열과 연결 리스트
- 배열이 물리적으로 연속적인 메모리 할당 방식으로 구현되기 때문에 배열을 연속된 메모리 주소의 집합이라고 여긴다.
	- 하지만 배열이 항상 연속된 메모리를 사용하는 것은 아니다.
	- 여기서 물리적 대신 논리적인 관점에서의 배열을 이해하는 것이 더 중요하다.
	- 배열(Array)이란 같은 자료형을 갖는 여러 원소(데이터)를 하나의 변수로 모아 놓은 데이터의 집합이다.
	- 배열은 인덱스-원소값 쌍의 집합으로, 하나의 인덱스가 주어지면 이와 연관된 원소값이 결정되는 대응 관계를 갖는다.
- 배열 표현의 가장 큰 특징은 원소의 논리적 순서와 저장된 물리적 순서가 같다는 것이다.
	- 따라서, 표현이 간단하고, 순서에 따른 순차적 원소 접근이 아니라 인덱스를 이용해서 빠른 임의 접근이 가능하다는 장점이 있다.
	- 이런 특성 때문에 임의의 순서로 데이터를 처리하는 경우에 유용하게 사용될 수 있다.
	- 하지만, 원소들이 순차적으로 저장되기 때문에 데이터의 삽입과 삭제가 발생하는 경우에는 시간적인 오버헤드가 발생한다는 단점이 있다.
		- 원소의 논리적 순서와 동일하게 물리적 순서를 유지하기 위해서 삽입/삭제가 수행되는 위치 이후에 있는 모든 원소를 한 자리씩 뒤나 앞으로 이동시켜야 한다.
			- 이러한 자료의 이동은 이동 대상이 되는 원소가 많을수록 부담이 커진다.
		- 배열의 크기가 대부분 정적으로 결정되기 때문에 삽입과 삭제가 동적으로 발생하는 상황에서 적절한 배열의 크기를 미리 결정하는 것이 어렵고, 이로 인해 오버플로나 저장공간의 낭비를 초래할 수 있다.
- 배열의 오버헤드/동적 처리 문제를 보완한 형태의 자료구조가 연결 리스트(Linked List)이다.
	- 연결 리스트에서 데이터의 논리적 순서와 물리적 순서를 매칭시킬 필요가 없다.
	- 연결 리스트의 물리적 순서는 연속적일 필요가 없되, 논리적 순서를 유지하는 것은 필수이다.
		- 이를 위해 하나의 데이터를 저장할 때 논리적으로 다음 데이터가 어디에 저장되어 있는지를 함께 나타내야 한다.
			- 따라서, 연결 리스트는 데이터 필드와 링크 필드로 이루어진 노드라는 저장구조를 이용한다.
- 연결 리스트에서 몇 개의 링크 필드만 조정하는 작업을 통해 삽입/삭제를 간단하게 수행할 수 있으며, 기억장치의 할당과 반환을 통해 동적으로 관리할 수 있다는 장점이 있다.
	- 하지만, 특정 데이터에 접근하려면 첫 번째 데이터를 가진 노드부터 시작하여 원하는 데이터가 있는 노드까지 사이에 있는 모든 노드를 순차적으로 방문해야 한다.
- ![[Pasted image 20230524180807.png|600]]

#### 1.2.2 스택과 큐
- **스택(Stack)** 은 리스트의 한쪽 끝에서만 데이터의 삽입과 삭제가 수행되는 자료구조를 나타낸다.
	- 가장 나중에 데이터가 가장 먼저 삭제되기 때문에 후입선출 (LIFO: Last-In-First-Out) 리스트라고 한다.
	- 스택에서 쌓아 올린 데이터의 개수를 표시하기 위해 일반적으로 top 이라는 변수를 사용한다.
	- 스택에서의 삽입 연산은 push 연산, 삭제 연산은 pop 연산이라고 한다.
	- ![[Pasted image 20230524181135.png|600]]
- **큐(Queue)** 는 리스트 한쪽 끝에서 데이터 삽입만 수행되고 다른 한쪽 끝에서 데이터 삭제만 수행되는 자료구조를 나타낸다.
	- 먼저 삽입된 원소가 먼저 삭제되므로 선입선출 (FIFO : First-In-First-Out) 리스트라고 한다.
	- ![[Pasted image 20230524181351.png|600]]

#### 1.2.3 트리
- **트리(Tree)** 는 **노드(Node)** 라고 하는 정보 항목이 **간선(Edge)** 으로 연결되어 계층적 구조를 이루는 비선형 자료구조로서, 다음 조건을 만족하는 하나 이상의 노드로 구성된 유한집합 $T$를 의미한다.
	- <mark class="hltr-trippy">조건 1)</mark> $T$의 원소 가운데 단 하나의 **루트(Root)** 노드가 존재한다.
	- <mark class="hltr-trippy">조건 2)</mark> 루트 노드를 제외한 나머지 노드는 $n$개($n \geq 0$)의 서로 분리된 부분 집합 $T_{1}, T_{2}, \cdots, T_{n}$ 으로 나누어지며, 각 $T_{i}$ 는 트리가 된다. 이때 각 $T_{i}$ 를 트리 $T$ 의 **서브트리(Subtree)** 라고 한다.

> [!info]- Wiki definition of Tree
> A [Tree](<https://en.wikipedia.org/wiki/Tree_(graph_theory)>) is an undirected graph $G$ that satisfies any of the following equivalent conditions:
> - $G$ is connected and acyclic (contains no cycles).
> - $G$ is acyclic, and a simple cycle is formed if any edge is added to $G$.
> - $G$ is connected, but would become disconnected if any single edge is removed from $G$.
> - $G$ is connected and the 3-vertex complete graph $K_{3}$ is not a [minor](https://en.wikipedia.org/wiki/Graph_minor) of $G$.
> - Any two vertices in $G$ can be connected by a unique simple path.
> 
> If G has finitely many vertices (say $n$ of them), then the above statements are also equivalent to any of the following conditions:
> - $G$ is connected and has $n-1$ edges.
> - $G$ is connected, and every subgraph of $G$ includes at least one vertex with zero or one incident edges ([1-degenerate](<https://en.wikipedia.org/wiki/Degeneracy_(graph_theory)>)).
> - $G$ has no simple cycles and has $n-1$ edges.

- 노드가 가진 서브트리의 개수를 해당 노드의 **차수(Degree)** 또는 **분기수** 라고 한다.
- 차수가 $0$인 노드를 **리프 노드(Leaf Node)** 또는 **단말 노드(Terminal Node)** 라고 한다.
- 단말 노드 이외의 나머지 노드를 **비단말 노드(Nonterminal Node)** 라고 한다.
	- **Internal Node** 라고도 하는 듯?
- 어떤 노드에서 분리된 노드를 **자식 노드(Child Node)** 라고 하며, 이런 자식 노드를 가진 노드를 **부모 노드(Parent Node)**, 같은 부모 노드 아래에 있는 모든 자식 노드들은 **형제 노드(Sibling Node)** 라고 한다.
- **조상 노드(Ancestor Node)** 는 특정 노드와 루트 노드 사이에 있는 모든 노드(특정 노드 제외, 루트 노드 포함)를 뜻하며, **후손 노드(Descendant Node)** 는 특정 노드와 단말 노드 사이에 있는 모든 노드(특정 노드 제외, 단말 노드 포함)을 뜻한다.
- **트리의 차수** 는 트리 내에 노드의 차수 중에서 최대 차수를 뜻한다.
- 노드의 **레벨(Level)** 은 루트 노드로부터 특정 노드까지 거리를 의미한다.
	- 루트 노드의 레벨은 $0$ 이며, 루트 노드의 자식 노드가 가진 레벨은 $1$ 이다.
- 트리의 **높이(Height)** 또는 **깊이(Depth)** 는 트리 내에 노드의 레벨 중에서 최대 레벨에 $1$ 을 더한 것이다.
- **숲(Forest)** 이란 $n(\geq 0)$ 개의 분리된 트리의 집합이다. 트리에서 루트 노드를 제거하면 숲이 된다.

> [!info] 트리 예시
> ![[Pasted image 20230525095727.png|500]]
> 위 그림에 트리는 A 노드가 루트 노드로, 총 14개의 노드로 구성되어 있다.
> - 차수 : A = 3, C = 0, F = 2
> - 리프/단말 : C, I, J, K, L, M, N
> - 부모/자식/형제 : 노드 G, H, I 는 노드 D 의 자식 노드이며 서로 형제 노드이며, 노드 D 는 이 노드들의 부모 노드이다.
> - 조상/후손 : 노드 M 의 조상은 노드 G, D, A 이다. 노드 B 의 후손은 노드 E, F, J, K, L 이다.
> - 트리의 차수 : 3
> - 레벨 : 노드 H 의 레벨은 2 이다.
> - 높이/깊이 : 4
> - 숲 : 트리에서 루트 노드 A 를 제거하면 3개의 트리로 이루어진 숲이 생긴다.

- #wiki A **Rooted Tree** is a tree in which one vertex has been designated the root.
- [순서 트리(Ordered Tree)](<https://en.wikipedia.org/wiki/Tree_(graph_theory)#Plane_tree>) 는 트리에서 노드의 배열 순서, 특히 레벨이 같은 노드의 좌우 위치가 중요한 의미를 갖는 트리이며, 그 반대를 **비순서 트리(Unordered Tree)** 라고 한다.
	- #wiki An **Ordered Tree** is a rooted tree in which an ordering is specified for the children of each vertex.
		- This is also called a **Plane Tree** because an ordering of the children is equivalent to an embedding of the tree in the place, with the root at the top and the children of each vertex lower than that vertex. Given an embedding of a rooted tree in the plane, if one fixes a direction of children (left-to-right), then an embedding gives an ordering of the children. Conversely, given an ordered tree, and conventionally drawing the root at the top, then the child vertices in an ordered tree can be drawn left-to-right, yielding an essentially unique planar embedding.
- 트리의 구조는 동일하나 각 노드의 내용이 다른 두 개의 트리는 **서로 닮았다**고 하며, 반면에 구조가 동일하며 동일한 위치에 동일한 내용을 가진 트리를 **대등한 트리**라고 한다.
- [이진 트리(Binary Tree)](https://en.wikipedia.org/wiki/Binary_tree) 는 각 노드의 차수가 $2$ 이하인 순서 트리이다.
	- 일반 트리에는 최소 한 개 이상의 노드가 있어야 하지만, 이진 트리에서 0개의 노드를 가진 공백도 포함된다.
	- 이진 트리는 순서 트리에 속하며, 자식의 순서를 구분하여 왼쪽 서브트리와 오른쪽 서브트리로 나눈다.
	- 이진 트리는 스레드 이진 트리, 힙, 이진 탐색 트리와 같이 다양한 형태로 여러 응용 영역에서 사용되는 매우 중요한 트리 구조이다.

> [!important] 이진 트리의 특성
> - 레벨 $i$ 에서의 최대 노드의 수는 $2^{i}$ 이다. 단, $i \geq \theta$.
> - 높이가 $h$ 인 이진 트리가 가질 수 있는 최대 노드의 수는 $2^{h}-1$ 이다. 단, $h \geq 1$.
> - 차수가 $2$ 인 노드 개수를 $n_{2}$ 라고 하면, 단말 노드의 개수는 $n_{0} = n_{2}+1$ 이다.

(트리의 높이를 $h$, 단말 노드의 총 개수를 $n_{0}$ 으로 표기함)
- **전 이진 트리 (Full Binary Tree)** : 모든 노드의 차수가 $0$ 또는 $2$ 인 이진 트리.
	- 전 이진 트리의 비단말 노드의 개수는 $n_{0}-1$ 이다.
	- 전 이진 트리의 노드의 개수는 $2h+1$ 에서 $2^{h+1}-1$ 사이의 값을 가진다.
	- ![[Pasted image 20230525114940.png|300]]
		- 비단말 노드 개수 = $6 - 1 = 5$
- **포화 이진 트리 (Perfect Binary Tree)** : 모든 리프 노드의 레벨이 같은 전 이진 트리.
	- 포화 이진 트리의 노드의 개수는 $2^{h}-1 == 2n_{0}-1$ 이다.
	- 포화 이진 트리의 단말 노드의 개수는 $2^{h-1}$, 비단말 노드의 개수는 $n_{0}-1$ 이다.
	- ![[Pasted image 20230525114925.png|300]]
		- 노드 개수 = $2^{4} - 1 = 2(8) - 1 = 15$
		- 단말 노드 개수 = $2^{4-1} = 8$
		- 비단말 노드 개수 = $2^{4-1}-1 = 7$
- **완전 이진 트리 (Complete Binary Tree)** : 트리의 최대 레벨이 $l$ 일 때, 레벨 $l-1$ 까지 포화 이진 트리를 형성하고, 레벨 $l$ 에서 왼쪽 가장자리에서 오른쪽 방향으로 중간에 빈자리 없이 리프 노드로 채워진 이진 트리.
	- 완전 이진 트리의 노드의 개수는 $2^{h-1}$ 에서 $2^{h}-1$ 사이의 값을 가진다.
	- ![[Pasted image 20230525115000.png|300]]
- **균형 이진 트리 (Balanced Binary Tree)** : 모든 노드에서 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이의 차이가 최대 $1$ 인 이진 트리.
	- 균형 트리의 노드의 총 개수를 $n$ 일 때, 트리의 높이는 $\lfloor \log_{2}n\rfloor + 1$  이다 ($floor(x)=\lfloor x \rfloor$)
	- ![[Pasted image 20230525115012.png|300]]

![[Pasted image 20230525150536.png|600]]

#### 1.2.4 그래프
- 그래프 $G$ 는 도형으로 표현되는 비선형 자료구조로서, 연결할 객체를 나타내는 정점(Vertex)의 집합 $V$ 와 정점을 연결하는 간선(Edge)의 집합 $E$ 로 구성되며, $G = (V, E)$ 로 표시된다.
- ![[Pasted image 20230525150807.png|600]]
- 그래프는 전기회로 분석, 프로젝트 분석, 최단 경로 탐색 등 실제적인 문제에 많이 응용되고 있다.
- 그래프는 간선의 방향성 여부에 따라 **무방향 그래프(Undirected Graph)** 와 **방향 그래프(Directed Graph)** 로 구분된다.
- 무방향 그래프는 간선을 나타내는 두 정점의 쌍에 순서가 없으며, 정점 $u$ 에서 정점 $v$ 사이의 간선을 $(u, v)$ 또는 $(v, u)$ 로 표시한다.
- 방향 그래프는 정점 $u$ 에서 정점 $v$ 로의 간선을 $<u, v>$ 로 표시하며, 이때 $u$ 는 **꼬리**이고 $v$ 는 **머리**라고 한다.
- 간선에 비용이나 시간과 같은 의미를 갖는 가중치를 부여한 그래프를 **가중 그래프(Weighted Graph)** 라고 한다.
- 트리는 그래프의 특별한 경우로, 연결된 무사이클 무방향 그래프가 트리이다.

> [!info] 그래프 예시
> ![[Pasted image 20230525153737.png|600]]
> 그래프 $G_{1}$ 은 가중 그래프에 해당되며, 그래프 $G_{2}$ 는 트리에도 해당된다.
> 
> 각 그래프에 대한 정점의 집합 :
> - $V(G_{1}) = {1,2,3,4}$
> - $V(G_{2}) = {1,2,3,4,5}$
> - $V(G_{3}) = {1,2,3,4}$
>
> 각 그래프에 대한 간선의 집합 :
> - $E(G_{1}) = {(1,2), (1,3), (2,3), (2,4), (3,4)}$
> - $E(G_{2}) = {(1,2), (1,3), (2,4), (3,5)}$
> - $E(G_{3}) = {<1,2>, <1,3>, <1,4>, <2,3>, <2,4>, <4,3>}$

- 두 정점 $u$, $v$ 사이에 간선이 있으면 정점 $u$ 와 $v$ 는 **인접(Adjacent)** 한다고 하며, 해당 간선은 정점 u 와 v 에 **부수(Incident)** 되었다고 한다.
- **부분 그래프(Subgraph)** : $V(G^{\prime}) \subseteq V(G)$ 이고 $V(G^{\prime}) \subseteq V(G)$ 인 그래프 $G^{\prime}$ 를 그래프 $G$ 의 부분 그래프라고 한다.
	- 정리하자면, 그래프 $G^{\prime}$ 의 정점과 간선이 그래프 $G$ 의 정점과 간선의 **부분 집합(Subset)** 이라면 그래프 $G^{\prime}$ 는 그래프 $G$ 의 부분 그래프이다.
- 그래프에서 정점 $v_{1}$ 부터 정점 $v_{n}$ 까지 연결된 정점의 순서 리스트 $v_{1}, v_{2}, \cdots, v_{n}$ 는 두 정점 사이의 **경로(Path)** 라고 부르며, 이때 경로에 존재하는 간선의 개수를 경로의 **길이(Length)** 라고 한다.
	- #wiki A Walk is a finite/infinite sequence of edges which joins a sequence of vertices.
		- #wiki A Trail is a walk in which all edges are distinct.
			- #wiki A Path is a trail in which all vertices (and therefore also all edges) are distinct.
- 한 정점에 부수된 간선의 수를 **차수(Degree)** 라 하며, 방향 그래프에서는 정점으로 들어오는 간선의 수를 **진입 차수(In-Degree)** 라 하고, 그 정점에서 나가는 간선의 수를 **진출 차수(Out-Degree)** 라고 한다.
- 한 경로에서 처음과 마지막 정점을 제외한 모든 정점이 서로 다른 경로를 **단순 경로(Simple Path)** 라고 한다.
- 처음과 마지막 정점이 같은 단순 경로를 **사이클(Cycle)** 이라 하며, 경로의 길이가 $1$ 인 사이클을 **루프(Loop)** 라고 한다.
- 무방향 그래프 $G$ 에서 서로 다른 두 정점 $u$, $v$ 의 모든 쌍(Pair)에 대해서 정점 $u$ 에서 $v$ 까지의 경로가 있으면 그래프 $G$ 는 **연결(Connected)** 되었다고 한다. 연결된 그래프에서 한 정점은 모든 정점과 이어져 있다고 보면 된다.
- 방향 그래프 $G$ 에서 서로 다른 두 정점 $u$, $v$ 의 모든 쌍에 대해서 $u$ 에서 $v$ 로의 방향 경로와 그 반대의 방향 경로가 존재하면, 그래프 $G$ 는 **강력 연결(Strongly Connected)** 되었다고 한다.
- 그래프를 구현할 때 **인접 행렬(Adjacency Matrix)** 또는 **인접 리스트(Adjacency List)** 를 사용한다.
- 그래프 $G$ 의 정점의 개수가 $n$ 이고, $n \times n$ 의 인접 행렬 $A$ 가 있다면, 원소 $A(i, j)$ 의 값은 $E(i, j)$ 이 존재하며 $E(i, j) \in E(G)$ 인 경우 $1$ 이고 그렇지 않다면 $0$ 이다 ($E<i, j>$ 경우도 마찬가지).
- 가중 그래프에 $E(i, j)$ 가 존재하는 경우 가선의 가중치를 $A(i, j)$ 의 값으로 나타내고, 간선이 없는 경우에는 $\infty$ 로 표현한다. $i == j$ 인 경우 $A(i, j)$ 의 값은 $0$ 으로 정한다.
- 인접 리스트는 인접 행렬의 $n$ 개의 각 행들을 연결 리스트로 표현한다. 즉, 그래프 $G$ 의 각 정점에 대하여 한 개의 연결 리스트가 존재한다.
- 각 노드에는 적어도 두 개의 필드(정점, 링크)가 있지만, 가중 그래프의 경우 가중치를 저장하기 위한 필드가 추가로 사용된다.
- 헤드 포인터 `head[i]` 는 정점 `i` 로부터 인접되어 있는 정점들을 나타내는 연결 리스트의 시작 주소를 갖는다.

![[Pasted image 20230525202238.png|600]]

### 1.3 알고리즘의 설계
- 주어진 숫자 목록에서 최댓값을 찾는 알고리즘은 여러 방식이 있지만 일단 직관적인 2 가지 방식을 검토해본다.
	- ![[Pasted image 20230525203817.png|600]]
	- ![[Pasted image 20230525203833.png|600]]
	- 최댓값을 찾는 두 알고리즘 중 어떤 것을 사용할지는 효율성에 따라 선택하면 된다.
	- 여기서 더 효율적이라는 것은 값들의 비교 횟수가 보다 적은 알고리즘으로, 여덟 개의 값 중 최댓값을 찾으려면 값을 몇 번 비교해야 하는지를 세어 보면 된다.
	- 일반적으로 $n$ 개의 숫자 중에서 최댓값을 찾기 위해서는 최소 n-1 번의 비교가 필요하다. 따라서, 일곱 번의 비교를 수행하는 알고리즘은 최적의 효율성을 가진 알고리즘이라 볼 수 있고, 두 알고리즘 중 어떤 알고리즘을 선택해도 무방하다.
- 주어진 데이터 중에서 원하는 값을 가진 데이터를 찾는 탐색 문제 알고리즘을 검토해본다. 우선 뒤섞여 있는 여러 카드 중에서 원하는 카드를 찾는 문제를 생각해본다.
	- 대부분의 사람들이 간단히 생각할 수 있는 방법은 처음부터 카드를 하나씩 뒤집어 가면서 원하는 카드가 나올 때까지 진행하는 것이다. 운이 좋으면 첫 번째 카드에서 찾을 수 있지만, 반대로 마지막 카드까지 모두 확인해야 하는 경우도 있을 수 있다. 이러한 방법을 **순차 탐색(Sequential Search)** 이라 부른다.
	- 카드에 적힌 숫자 크기에 따라 카드가 나열된 경우 (왼쪽->오른쪽 오름차순), **이진 탐색(Binary Search)** 을 사용하면 보다 효율적으로 원하는 카드를 찾을 수 있다.
		- 주어진 카드 중에서 중앙의 카드를 확인한다. 원하는 숫자라면 탐색이 종료되지만, 아니라면 중앙 카드의 숫자와 원하는 숫자와 비교한다. 원하는 숫자가 중앙 카드의 숫자보다 작은 경우, 가장 왼쪽 카드에서 중앙 카드 바로 직전 카드까지를 대상으로 탐색을 반복한다 (큰 경우 가장 오른쪽에서).

```C
// 순차 탐색 코드
SequentialSearch (A[], n, x) {
	for (i=0;i<n;i++)
		if (x==A[i]) return i;
	return -1;
}
```

```C
// 이진 탐색 코드
BinarySearch (A[], Left, Right, x) {
	// A[Left..Right] : 탐색 대상 배열. 오름차순으로 정렬되어 있다고 가정
	// Left, Right : A에서 x를 찾는 구간
	// x : 탐색키
	if (Left>Right) return -1; // 탐색이 실패한 경우
	Mid = floor((Left+Right)/2); // 중간 값
	if (x==A[Mid]) return Mid; // 중간 값이 원하는 값인 경우
	else if (x<A[Mid]) BinarySearch(A, Left, Mid-1, x); // 원하는 값이 작은 경우
		else BinarySearch(A, Mid+1, Right, x); // 원하는 값이 큰 경우
}
```

- 뒤섞여 있는 경우와 순서대로 나열된 경우처럼 데이터가 주어진 상태에 따라 알고리즘도 달라질 수 있다.
	- 이와 같이 우리가 해결하려는 문제, 속성, 조건 등이 매우 다양하므로 모든 문제 혹은 대부분의 문제에 대해서 일반적으로 적용할 수 있는 알고리즘은 존재하지 않는다.
	- 하지만 비교적 단순하면서 많은 부류의 문제에 사용 가능한 기법으로 **분할정복(Divide-and-Conquer)**, **동적 프로그래밍(Dynamic Programming)**, **욕심쟁이(Greedy)** 방법 등이 있다.

### 1.4 알고리즘의 분석
- 설계한 알고리즘은 무엇보다 정확하고 효율적인 알고리즘이어야 한다. 따라서, 알고리즘의 설계를 마친 후에는 알고리즘이 원하는 결과를 정확히 생성하는지 확인해야 하며, 또한 해당 알고리즘을 수행하려면 컴퓨터 자원이 얼마나 필요한지를 분석해야 한다.

#### 1.4.1 정확성 분석
- 정확한 알고리즘이라면 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성해야 한다.
- 정확성 분석을 위해서는 다양한 수학적 기법을 사용하여 알고리즘이 예상한 대로 수행되는지에 대해 증명해야 한다.
	- (이 과정은 복잡하고 어려워 이 책에서는 다루지 않으며, 정확성이 이미 증명된 알고리즘에 대해서만 취급한다.)

#### 1.4.2 효율성 분석
- 일반적으로 "알고리즘 분석"이 뜻하는 것은 정확성 측면보다는 효율성, 즉, 알고리즘이 주어진 문제를 시간적(필요한 수행 시간) 또는 공간적(필요한 메모리 양)으로 얼마나 효율적으로 풀 수 있는지를 판단하는 것을 의미한다.
- 이런 관점에 있어 "효율적인 알고리즘"은 가능한 적은 메모리와 빠른 수행 시간을 갖는 알고리즘을 의미한다.

##### 공간 복잡도
- 알고리즘의 **공간 복잡도(Space Complexity)** 는 알고리즘을 실행시켜 완료할 때까지 필요한 총 메모리의 양을 말한다.
- 알고리즘을 수행하기 위해 필요한 공간은 정적 공간과 동적 공간으로 이루어진다.
	- 정적 공간은 컴파일 과정에서 고정적으로 결정된다.
	- 동적 공간은 실행 시간에 동적 할당이나 함수 호출 등으로 동적으로 결정된다.

##### 시간 복잡도
- 알고리즘의 시간 복잡도(Time Complexity) 는 알고리즘을 실행시켜 완료될 때까지 걸리는 시간을 말한다.
- 알고리즘의 수행 시간은 여러 요인에 의해 영향을 받는다. 따라서, 이러한 종속적인 요인을 배제해야만 객관적인 평가가 가능하다.
	- 컴퓨터
	- 프로그래밍 언어
	- 알고리즘
	- 프로그램 구조
	- 컴파일러
- 일반적으로 알고리즘의 수행 시간은 알고리즘에서 단위 연산이 얼마나 많이 수행되는가에 비례한다.
- 알고리즘의 수행 시간은 입력 데이터의 크기에 따라 늘어나기 때문에 (단위 연산 개수의 합 대신에) 입력 크기 $n$ 에 대한 함수로 표현하는 것이 바람직하다.
- 알고리즘의 수행 시간은 주어진 입력 데이터의 상태에 따라 영향을 받는다.
	- 데이터가 이미 정렬된 상태인 경우 가장 빠른 수행 시간을 보이는 알고리즘이 있다. 하지만 이러한 알고리즘은 데이터가 정렬되지 않은 경우에 가장 나쁜 성능을 보이기도 한다.
	- 데이터가 항상 알고리즘에 가장 적합한 상태로 주어진다고 가정할 수 없으므로, 최선의 수행 시간이 아닌 일반적인 상황에서 소요되는 시간을 추정하는 것이 바람직하다.
	- 다양한 상태로 제공되는 모든 입력의 경우에 대해 각각의 수행 시간을 계산한 후 이들로부터 평균 시간을 택하는 것도 방법이지만, 상황에 따라 수행 시간 편차가 클 수 있음으로 여러 알고리즘을 비교하기에 적합하지 않다.
	- 따라서, 최선이나 평균 수행 시간이 아닌 최악의 수행 시간을 시작 복잡도를 평가하는 일반적인 척도로 사용한다. 최악 수행 시간은 알고리즘 수행 시간의 상한을 의미하며, 어떤 입력이 주어지더라도 이것 이상의 수행 시간은 걸리지 않는다는 것을 보장한다.

> [!info] 알고리즘 수행 시간 계산 예시

```C
SumAverage(A[], n) {}
```

### 1.5 점근성능
### 1.6 순환 알고리즘의 성능

## 2. 분할정복 알고리즘
### 2.1 분할정복 방법의 원리
### 2.2 이진 탐색
### 2.3 합병 정렬
### 2.4 퀵 정렬
### 2.5 선택 문제

## 3. 동적 프로그래밍 알고리즘
### 3.1 동적 프로그래밍 방법의 원리
### 3.2 피보나치 수열 문제
### 3.3 연쇄 행렬 곱셈 문제
### 3.4 스트링 편집 거리 문제
### 3.5 모든 정점 간의 최단 경로
### 3.6 저울 문제

## 4. 욕심쟁이 알고리즘
### 4.1 욕심쟁이 방법의 원리
### 4.2 동전 거스름돈 문제
### 4.3 배낭 문제
### 4.4 최소 신장 트리
### 4.5 최단 경로
### 4.6 작업 스케줄링 문제
### 4.7 작업 선택 문제
### 4.8 허프만 코딩

## 5. 정렬 알고리즘
### 5.1 정렬의 개념
### 5.2 버블 정렬
### 5.3 선택 정렬
### 5.4 삽입 정렬
### 5.5 셸 정렬
### 5.6 합병 정렬과 퀵 정렬
### 5.7 힙 정렬
### 5.8 비교 기반 정렬의 하한
### 5.9 계수 정렬
### 5.10 기수 정렬

## 6. 탐색 알고리즘
### 6.1 탐색의 개념
### 6.2 순차 탐색
### 6.3 이진 탐색
### 6.4 탐색 트리
### 6.5 해싱

## 7. 근사 알고리즘
### 7.1 기본 개념
### 7.2 클래스 P와 클래스 NP
### 7.3 NP-완전 문제와 NP-하드 문제
### 7.4 근사 알고리즘

## 8. 해 탐색 알고리즘
### 8.1 되추적 알고리즘
### 8.2 분기한정 알고리즘
### 8.3 유전 알고리즘

# 끝